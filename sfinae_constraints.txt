SFINAE constraints
==================

[[Parent]]: techniques.txt

16.05.2015

_SFINAE_ --- an acronym for Substitution Failure Is Not An Error --- is a rule in the C++ standard. The rule states that if the substitution of a template-declaration generates errors, then the declaration is removed from the overload-set, and the errors are ignored.

Context
-------

The SFINAE rule is only in effect when it occurs in a template _declaration_. That is,

* in the return-type of a function-template, or
* in a parameter-type of a function-template, or
* in a template parameter.

In particular,

* errors in the base-class list are not SFINAE errors; they are actual errors, and
* errors in the function/class definition are not SFINAE errors; they are actual errors.

Constraining the overload set
-----------------------------

The SFINAE rule can be abused to constrain the parameter-types of a function/class template. This modifies which overload-sets the function/class participates in. 

### Example

Suppose we have

[[CppCode]]:
	template <typename Type>
	Type f(Type that);

and would like to constrain `f` to only work on native integer types. We can do this with SFINAE as follows:

[[CppCode]]:
	enum class Enabler;

	template <bool Condition, typename Type = Enabler>
	struct EnableIfC_F
	{
		using type = Type;
	};

	template <typename Type>
	struct EnableIfC_F<false, Type>
	{};

	template <bool Condition, typename Type>
	using EnableIfC = 
		typename EnableIfC_F<Condition, Type>::type;

	template <typename Condition, typename Type>
	using EnableIf = 
		EnableIfC<Condition::value, Type>;

	template <
		typename Type,
		EnableIf<std::is_integral<Type>...>
	Type f(Type that);

When `f` is called with something else than a native integer type, the `std::integral<Type>::value` evaluates to `false`, and the latter template-parameter becomes `typename EnableIfC_F<false>::type...`. Since `EnableIfC_F<false>` does not contain a `type` member, an error occurs. Since the error occurs due to a  substitution in a template declaration, the SFINAE rule applies, and the function is removed from the overload set.

Where to place the SFINAE-constraint
------------------------------------

The SFINAE-constraint can be embedded in many ways into the declaration; some choices are better than others.

### SFINAE-constraint in a parameter-type

The SFINAE-constraint can be placed in the return-type:

[[CppCode]]:
	template <typename Type>
	EnableIf<std::is_integral<Type>, Type> f(Type that);

The disadvantage is that the function is harder to understand, since the return-type is garbled.

### SFINAE-constraint in a parameter-type.

The SFINAE-constraint can be placed in a parameter-type:

[[CppCode]]:
	template <typename Type>
	Type f(Type that, EnableIf<std::is_integral<Type>>* = 0);

The disadvantage is that the function is harder to understand, since there is an extraneous parameter which is not meaningful to the user.

### SFINAE-constraint in a template-parameter type (C++11)

The SFINAE-constraint can be placed in a template-parameter type:

[[CppCode]]:
	template <
		typename Type,
		typename = EnableIf<std::is_integral<Type>>>
	Type f(Type that);

The disadvantage is that this does not always work:

[[CppCode]]:
	template <
		typename Type,
		typename = EnableIfC<!std::is_integral<Type>::value>>
	void f()
	{}

	template <
		typename Type,
		typename = EnableIfC<std::is_integral<Type>>>
	void f()
	{}

Rather than dividing `f` in two cases, this redefines the same function `f`; the return-type, the parameters, and the template-parameters are equal, and the default template-parameter does not differentiate the two.

### SFINAE-constraint in a template-parameter value (C++11)

The SFINAE-constraint can be placed in a template-parameter value:

[[CppCode]]:
	template <
		typename Type,
		EnableIf<std::is_integral<Type>>* = 0>
	Type f(Type that);

The disadvantage is that there is an extraneous template-parameter which has no meaning for the user.

### SFINAE-constraint in a template-parameter value-pack (C++11)

The SFINAE-constraint can be placed in a template-parameter value-pack:

[[CppCode]]:
	template <
		typename Type,
		EnableIf<std::is_integral<Type>>...>
	Type f(Type that);

The disadvantage is that there is an extraneous template-parameter-pack which has no meaning for the user. However, since the `Enabler` is only declared, not defined, the user can never provide those template-parameters. 

### Choice in Pastel

Storing the SFINAE-constraint in the template-parameter value-pack seems like a good approach. Unfortunately, Visual Studio 2015 RC has a bug in the compiler, and cannot deal with it. Therefore, for the time being, we chose to store the SFINAE-constraint in a template-parameter value.

Standard library
----------------

The C++ Standard library provides the `std::enable_if_t` template, for which `std::enable_if_t<Condition, Type>` is equivalent to `EnableIfC<Condition, Type>`, and `std::enable_if_t<Condition>` is equivalent to `EnableIfC<Condition, void>`. Pastel uses `EnableIf`, `EnableIfC`, `DisableIf`, and `DisableIfC`.

Future
------

Using the SFINAE rule is --- as of May 2015 --- the only way to implement template constraints. It was not intended for this task, which shows in that it makes code harder to understand, and that it changes the declaration itself in a way which is not meaningful to the user. A proper language support for template constraints is upcoming in the form of the Concepts Lite Technical Specification. 
