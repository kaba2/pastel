SFINAE constraints
==================

[[Parent]]: techniques.txt

16.05.2015

_SFINAE_ --- an acronym for Substitution Failure Is Not An Error --- is a rule in the C++ standard. The rule states that if the substitution of a template-declaration generates errors, then the declaration is removed from the overload-set, and the errors are ignored.

Context
-------

The SFINAE rule is only in effect when it occurs in a template _declaration_. That is,

* in the return-type of a function-template, or
* in a parameter-type of a function-template, or
* in a template parameter.

In particular,

* errors in the base-class list are not SFINAE errors; they are actual errors, and
* errors in the function/class definition are not SFINAE errors; they are actual errors.

Constraining the overload set
-----------------------------

The SFINAE rule can be abused to constrain the parameter-types of a function/class template. This modifies which overload-sets the function/class participates in. 

Using the SFINAE rule is --- as of May 2015 --- the only way to implement template constraints. It was not intended for this task, which shows in that it can make code harder to understand, and/or change the declaration in a way which is not meaningful to the user. A proper language support for template constraints is upcoming in the form of the Concepts Lite Technical Specification. 

### Example

Suppose we have

[[CppCode]]:
	template <typename Type>
	Type f(Type that);

and would like to constrain `f` to only work on native integer types. We can achieve this using SFINAE as follows:

[[CppCode]]:
	template <bool Condition, typename Type = int>
	struct RequiresC_F
	{
		using type = Type;
	};

	template <typename Type>
	struct RequiresC_F<false, Type>
	{};

	template <bool Condition, typename Type>
	using RequiresC = 
		typename RequiresC_F<Condition, Type>::type;

	template <typename Condition, typename Type>
	using Requires = 
		RequiresC<Condition::value, Type>;

	template <
		typename Type,
		Requires<std::is_integral<Type> = 0>
	Type f(Type that);

When `f` is called with something else than a native integer type, the `std::integral<Type>::value` evaluates to `false`, and the latter template-parameter becomes `typename RequiresC_F<false>::type`. Since `RequiresC_F<false>` does not contain a `type` member, an error occurs. Since the error occurs due to a  substitution in a template declaration, the SFINAE rule applies, and the function is removed from the overload set.

Where to place the SFINAE-constraint
------------------------------------

The SFINAE-constraint can be embedded in many ways into the declaration; some choices are better than others. Knowing all of them is useful for working around bugs in the compiler (i.e. Visual C++ 2015 RC); if one does not work, then usually some other does.

### SFINAE-constraint in a parameter-type

The SFINAE-constraint can be placed in the return-type:

[[CppCode]]:
	template <typename Type>
	Requires<std::is_integral<Type>, Type> f(Type that);

The disadvantage is that the function is harder to understand, since the return-type is garbled.

### SFINAE-constraint in a parameter-type.

The SFINAE-constraint can be placed in a parameter-type:

[[CppCode]]:
	template <typename Type>
	Type f(Type that, Requires<std::is_integral<Type>> = 0);

The disadvantage is that the function is harder to understand, since there is an extraneous parameter which is not meaningful to the user.

### SFINAE-constraint in a template-parameter type (C++11)

The SFINAE-constraint can be placed in a template-parameter type:

[[CppCode]]:
	template <
		typename Type,
		typename = Requires<std::is_integral<Type>>>
	Type f(Type that);

The disadvantage is that this does not allow for constraint-based overloading. Suppose we later add the following overload:

[[CppCode]]:
	template <
		typename Type,
		typename = RequiresC<!std::is_integral<Type>::value>>
	Type f(Type that)
	{}

Rather than dividing `f` into two cases, this redefines the same function template `f`; the return-type, the parameters, and the template-parameters are equal, and the default template-parameter does not differentiate the two.

_Since such overloads may need to be added later, this technique should be avoided._

### SFINAE-constraint in a template-parameter literal (C++11)

The SFINAE-constraint can be placed in a template-parameter literal:

[[CppCode]]:
	template <
		typename Type,
		Requires<std::is_integral<Type>> = 0>
	Type f(Type that);

The disadvantage is that there is an extraneous template-parameter which has no meaning for the user:

[[CppCode]]:
	// This is a valid call.
	f<int, 1>(4);

### SFINAE-constraint in a template-parameter literal-pack (C++11)

The SFINAE-constraint can be placed in a template-parameter literal-pack:

[[CppCode]]:
	template <
		typename Type,
		Requires<std::is_integral<Type>>...>
	Type f(Type that);

The disadvantage is that there is an extraneous template-parameter-pack which has no meaning for the user:

[[CppCode]]:
	// This is a valid call.
	f<int, 1, 2, 3>(4);

An advantage of this technique over the literal one is that the default template-parameter need not be specified. Then the type underlying `Requires` (now `int`) can be changed to `enum class Enabler` --- which is declared, but not defined. This makes it impossible for the user to provide template-arguments in the literal-pack.

_Visual C++ 2015 RC has a bug in the compiler, and cannot deal with the literal-pack approach._

Pastel
------

In Pastel, we choose to store the SFINAE-constraint in a template-parameter literal --- unless we need to work around a bug in the compiler. 

The `Requires` type in this section corresponds to `EnableIf` in the library. The `Requires` type in the library takes a template-pack of conditions, combines them with logical-and, and passes that to `EnableIf`.

Standard library
----------------

The C++ Standard library provides the `std::enable_if_t` template, for which `std::enable_if_t<Condition, Type>` is equivalent to `RequiresC<Condition, Type>`, and `std::enable_if_t<Condition>` is equivalent to `RequiresC<Condition, void>`. Pastel provides and uses `Requires`, `RequiresC`, `DisableIf`, and `DisableIfC`.

