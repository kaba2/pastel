Red-black forest notes
======================

[[Parent]]: red_black_forest.txt

Sentinel node
-------------

The _sentinel tree_ is a singular tree, which consists of a single node, the _sentinel node_. The sentinel node is used to denote a missing children for the nodes in the forest. This removes boundary cases from the problem, and the sentinel node also works as the one-past-end iterator. The left child of the sentinel node is the sentinel node itself. This property is unique to the sentinel node, and thus can be used to identify the sentinel node locally. In the following, we shall denote the sentinel tree, and also the sentinel node, by S. 

Chaining
--------

A chaining is a way to link the red-black trees such that the elements of the forest can be traversed by in-order traversal. A chaining can be achieved at least in the following ways:

* in _max-root_ chaining, the right child of the maximum of a tree is the root of the next tree, and the parent of the root of a tree is the maximum of the previous tree,
* in _root-min_ chaining, the parent of the root of a tree is the minimum element of the next tree, and the left child of the minimum of a tree is the root of the previous tree,

Here's a visualization of the max-root chaining:

	  .<------------+
	 /S\            |
	/___\           |
	     ^          |
	      v         |
	     / \        |
	    /___\       |
	         ^      |
	          v     |
	         / \    |
	        /___\ <-+


Here's a visualization of the root-min chaining:

	+------------>.              
	|            / \  
	|           /___\ 
	|          ^      
	|         v       
	|        / \      
	|       /___\     
	|      ^  
	|     v   
	|    /S\  
	+-> /___\ 

The max-root chaining is favorable to root-min chaining, because it provides constant-time complexity for moving between the sentinel node and the last node; in root-min chaining this would be proportional to the height of the last tree. This is important, because it is a common task to find the last node by backing out from the sentinel node. 
From now on we will assume the use of max-root chaining.

Starting a search from the minimum node
---------------------------------------

In a complete binary tree of height ''h'', the expected number of moves in a search starting from the minimum (or maximum) node is

[[Equation]]:
	1 / (2^(h - 1)) sum_{k = 1}^{h - 1} 2 k 2^(k - 1).

This has an exact solution of

[[Equation]]:
	2 (h - 2) + 2^(2 - h).

Dividing this by ''h - 1'' gives the ratio of moves compared to the search starting from the root. The first numbers in this sequence, starting from ''h = 2'', are

	1.0000    1.2500    1.4167    1.5313    1.6125    1.6719    1.7165    1.7510    1.7782    1.8002    
	1.8183    1.8334    1.8462    1.8572    1.8667    1.8750    1.8824    1.8889    1.8947

This sequence is increasing, and its limit is 2. Therefore a good rule of thumb is that the search starting from the minimum node takes roughly twice the time the search takes from the root node.

Root nodes
----------

The root of each tree can be found in time proportional to the height of the tree, provided one is given some node of the tree. But should the root of each tree be accessible in constant time? This is useful, since 

* starting searches from the root minimizes the number of node-moves in the worst-case, and is also roughly twice as fast on average when compared to starting from the minimum (or maximum) node,
* the root contains the summary of the contained hierarchical information.

When the forest contains multiple trees, storing the root with each tree seems like a waste of memory. To access the root in constant time, each node would have to store a reference to its tree, and the tree to store its root. That takes too much memory. This is taken to the extreme with a degenerated list.

When the forest contains a single tree, the root is needed to guarantee that the generalization from a tree to a forest has the same search performance. The root of the first tree is stored as the right child of the sentinel node. The minimum node is traced explicitly.

Problem: can a root-node be identified locally without additional encoding? For a tree with at least two elements, a node is a root-node if the right-child of its parent is not the node itself? Not sure if works. For a singular tree, the problem seems even harder.

Isolating trees during operations
---------------------------------

The trees themselves are modified by the red-black tree algorithms. It is therefore problematic that the right child of the maximum node is a node in the next tree, and that the parent node of each root is a node in the previous tree. 

### Solution 1

Generalize the red-black tree algorithms to take care of root nodes. This requires a new bit in each node to identify a root node.

Interface
---------

The interface is based on two principles:

* it is usable as a list, and
* it is usable as a single tree.

To this end, we offer three types of functions: 

* those that the user does not localize are localized by the root node of the first tree,
* those that the user localizes act on the tree the localization iterator is part of,
* those that the user localizes by the end-iterator operate on a yet non-existing tree at the end of the sequence.

### Insertion

The corresponding calls are as follows:

[[CppCode]]:
	insert(key)
	insert(near, key)
	insert(end, key)

The first inserts a key into the first tree. The second inserts a key into the tree which the `near` iterator is part of. The third creates a new tree at the end of the sequence. We will also create the functions `pushBack` and `pushFront` which create a new tree at the start and at the end of the sequence, respectively. The `pushBack(key)` is equivalent to `insert(end, key)`. Note how all this is consistent with how `std::list` works.

### Searches

The searches concern `find`, `lowerBound`, and `upperBound`. We will use `find` as an example. The corresponding calls are as follows:

[[CppCode]]:
	find(key)
	find(near, key)
	find(end, key)

The first searches for a key in the first tree. The second searches for a key in the tree pointed to by `near`. The third never finds anything.

### Removal

The calls are as follows:

[[CppCode]]:
	erase(key)
	erase(element)
	erase(end)

The first is equivalent to `erase(find(key))`. The second removes an element given to it. The third does not do anything.

Hierarchical information
------------------------

The linking between the trees causes a problem when updating hierarchical information. With a single tree, the update procedure can work without special cases, since the sentinel node contains the base information which is then propagated. But now the right child of the maximum node is in the next tree, and should not leak information into the current tree.

Failed ideas
------------

### Root-max-min chaining

In _root-max-min_ chaining, the right child of the maximum element of a tree is the minimum element of the next tree, and the parent of a root of a tree is the maximum element of the previous tree. Here's a visualization of the root-max-min chaining:

      +------------------+
      |                  |
	  .   +---.   +---.  |
	 /S\ /   / \ /   / \ v
	/___\-->/___\-->/___\.
	^                    |
	+--------------------+

In root-max-min chaining the transition from a maximum node of a tree to the minimum node of the next tree takes only constant time. It also encodes both the minimum and the maximum node in the sentinel node. By a careful formulation, the in-order traversal can be made to work with this chaining.

Problem: the links can not be updated efficiently, for example when a new maximum node is inserted in a tree.

### Max-min chaining

In _max-min_ chaining, the right child of the maximum element of a tree is the minimum element of the next tree, and the left child of the minimum element of a tree is the maximum element of the previous tree. 

Problem: the in-order traversal fails for this chaining.
