Iterator ranges
===============

[[Parent]]: range.txt

Theory
------

In Pastel, an _iterator range_ is a triple `(b, e, d)`, 
where `b` and `e` are iterators and `d` is the distance between 
`b` and `e`. The iterators which can be reached from `b` before
reaching `e` are said to be _in the range_. The set of these
iterators is denoted by `[b, e[`. Such a range can be 
described by giving `b` and either `e` or `d`, since `e` and `d` 
are redundant.

There are three kinds of iterator ranges corresponding to the
three kinds of iterators, which are forward, bidirectional, and
random-access, corresponding to the iterator categories in the
C++ Standard Library.

Each iterator range is also a range.

Ranges vs iterator ranges
-------------------------

Ranges are strictly more expressive than iterator ranges. Ideally,
we would not have an iterator range concept, but only the range concept. 
However, the whole of Standard Template Library is based on iterators,
and there the iterator ranges are formed implicitly by passing iterators
in pairs. Therefore, to be able to take advantage of the STL algorithms,
the used range concept must be built on top of iterators, such that
the individual iterators can be both packed into iterator ranges, and
then, when needed, unpacked back to iterators. The Boost.Range library
implements this idea well. The iterator range classes, defined by Pastel,
work directly with the Boost.Range library. However, at the same time
they are also full-blown ranges, and thus seamlessly integrate with 
Pastel.

Describing iterator ranges
--------------------------

There are two useful ways to describe an iterator range.
The first is as an iterator pair. The second is as a
starting iterator and a number of elements. The first option
is emphasized by the C++ Standard Library in that it misses
some versions of algorithms that would take a range in the
second form. However, there is no reason why this should be
the case and this is why the next C++0x standard adds those missing
functions.

A problem with iterator ranges is that for some containers,
determining the ending iterator from the number of elements 
(or vice versa) is a linear operation, requiring to traverse
through all the elements in between. Pastel avoids this problem,
or at least pushes it forward, by lazily evaluating the missing
information. For example, if the iterator range is given as an iterator
pair, then the number of elements is only evaluated if it is
asked for. Note that the performance problem only exists with
iterators that are not random-access.

The iterator ranges act as much as possible as the containers,
which can be seen by looking at their interface.

Iterators vs iterator ranges
----------------------------

The use of iterator ranges offers more compact interfaces
to functions, since the number of parameters for each range
is cut to half. In addition, function templates turn from 
unconstrained to requiring the parameter to be an iterator range.
This resembles concept-based overloading.

Hierarchy
---------

A random-access iterator range is a bidirectional iterator range.
Similarly, a bidirectional iterator range is a forward iterator range.
This is reflected in RandomAccessIterator_Range class being derived
from BidirectionalIterator_Range which is in turn being derived from ForwardIterator_Range.

Construction
------------

Iterator ranges can be constructed from an iterator pair, an
iterator and a size, or a native array, by using the `range()` 
functions in [[FileLink: iterator_range.h]]. Using meta-programming, 
the function's return type is determined appropriately from the 
iterator's type, i.e., if the passed-in iterator is a bidirectional 
iterator, then a bidirectional range is returned. For example:

[[CppCode]]:
	std::vector<real> inputSet(8, 1);
	dct(range(inputSet.begin(), inputSet.end()));

	real otherSet[8];
	dct(range(otherSet));

If a data structure in Pastel exposes a `begin()` and `end()` sequence 
iterator interface, then it also exposes a corresponding iterator range
`range()` member function. For example, [Array][Array] does this.

[Array]: [[Ref]]: array.txt


