Red-black forest
================

[[Parent]]: data_structures.txt

A _red-black forest_ is a data-structure for storing and manipulating a locally ordered sequence. It consists of a sequence of [red-black trees][RedBlack], with the end-nodes in a doubly-linked list. A red-black forest is useful because it offers a way to do finger searches; the trees localize the searches. The red-black forest implementation in Pastel has the following properties:

Task / Property                                   | Complexity                       | Amortized complexity
--------------------------------------------------|----------------------------------|--------------------------------
Insert/remove an empty tree.                      | ''Theta(1)''                     |
Move a tree to another forest.                    | ''Theta(1)''                     |
Move all trees to another forest.                 | ''Theta(1)''                     |
Find out the number of trees.                     | ''Theta(1)''                     |
Find the next/previous tree, given a tree.        | ''Theta(1)''                     |
Find the next/previous element, given an element. | ''O(log(n_i) + k) cap Omega(k)'' | Monotonic traversal: ''Theta(k)'' 
Find the containing tree, given an element.       | ''O(log(n_i)) cap Omega(1)''     |
Space                                             | ''Theta(n)''                     |

Here ''n'' is the number of elements in the forest, and ''n_i'' is the number of elements in the ''i'':th set, with ''{j, k} = {i, i + 1}'' such that ''n_k <= n_j''. The ''k'' is the number of empty trees that must be skipped to get to the next/previous element.

[RedBlack]: [[Ref]]: redblacktree.txt

Additional properties
---------------------

Each red-black tree created in a given red-black forest shares the bottom-node of that red-black forest. This allows, by default, the trees in the forest to be joined together. However, sharing a bottom-node is not enforced by the red-black forest. In fact, the user is given a direct access to each red-black tree.

Versus truncated skip-list
--------------------------

A [truncated skip-list][SkipList] can also do finger searches, using the elements itself as fingers. The problem is that the height of the truncated skip-list must be fixed, and therefore its insertion and removal can not be completely localized. In addition, a red-black tree is faster and more space-efficient than a skip-list, while also supporting propagation data.

[SkipList]: [[Ref]]: skiplist.txt

Faster skipping of empty trees
------------------------------

The complexity of finding the next/previous element, given an element, is linear in the number of skipped empty trees. It is possible to decrease this complexity to ''O(1)'' amortized by using a secondary red-black forest to store subsequences of the primary red-black forest. A tree of the secondary forest then consists either of a singular set of a primary tree, or a maximal subsequence of empty primary trees.
