Incidence graph
===============

[[Parent]]: data_structures.txt

The `Incidence_Graph` is a data structure for storing and manipulating 
labeled graphs. 

Graphs
------

A _graph_ is a triple ''(V, E, I)'', where ''V'' and ''E'' are finite 
sets, called the _vertices_ and the _edges_, respectively, and 
''I : E --> V^2 times {0, 1}'' is called the _incidence function_.
The incidence function tells for each edge its end-vertices, and
whether the edge is directed (1) or not (0). If an edge ''e'' is 
directed, then the first element and the second element of 
''I(e)'' denote the origin vertex and the destination vertex,
respectively. This generality is required to represent all of 
undirected graphs, directed graphs, and mixed graphs, possibly 
combined with self-loops and multi-edges. A _labeled graph_ is
a graph together with _labeling functions_ ''L_V : V --> D_V''
and ''L_E : E --> D_E'', where ''D_V'' and ''D_E'' are arbitrary
sets, called the _vertex labels_ and the _edge labels_, respectively.

Data structure
--------------

The following describes the properties of the incidence graph
data structure.

### Generality

 * supports directed, undirected, and mixed graphs, with the
 type of the graph being selectable at compile time,
 * supports arbitrary graphs, including self-loops and
 multi-edges,
 * provides a way to store user data (labels) in vertices and 
 edges,

### Operations and time optimality

 * can add vertices dynamically, in constant time,
 * can remove vertices dynamically, with the incident edges 
 also being removed, in time linear in the number incident 
 edges,
 * can add and remove edges arbitrarily, in constant time,
 * can provide a list of its vertices, as well as the number
 of vertices, in constant time,
 * can provide a list of its edges, as well as the number
 of edges, in constant time,
 * can provide for each vertex separate lists of its incoming, 
 outgoing, and incident undirected edges each in constant time, 
 as well the size of those lists; the opposing vertices can be
 obtained without needing to compare vertices,
 * can provide for each edge its end-vertices, in constant time,
 
### Space optimality

 * does not use any extra memory in supporting the different
 kinds of graphs; directed and undirected graphs do not use 
 memory to store undirected and directed edges, respectively,
 * the use of labels is optional at compile-time; no memory
 is used for the labels if they are not used,

### Preservation of identity

 * preserves the identity (memory address) of vertices and 
 edges during their lifetime, and
 * can change the directionality of an edge without changing
 the identity of the edge.
