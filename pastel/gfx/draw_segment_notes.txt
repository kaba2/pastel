A generalized midpoint algorithm for drawing line segments
==========================================================

[Parent]: draw.txt

Abstract
--------

Here we derive a generalized midpoint algorithm for drawing 
line segments. This generalized version works with floating point 
end-points instead of integer end-points.

Problem
-------

In the following the norm is assumed to be the maximum norm and
''\exists!'' stands for _unique existence_.
Given two points ''A, B in RR^2'', the problem is to generate a
sequence ''P = {p_1, ..., p_m} sub ZZ^2'' such that:

 * ''\forall i in [1, m]: \exists! k in [1, m]: k != i => |p_i - p_k| = 1''
 
 * ''\forall t in [0, 1] sub RR: \exists! k in [1, m]: |(A + t(B - A)) - p_k| <= 1''

I.e. informally the problem is to draw a set of pixels ''{(x(i), y(i))}''
such that they form an 8-connected one-pixel wide line segment 
from ''A'' to ''B''.

Solution
--------

We take the sampling point of a pixel ''(x, y)'' to
be at ''(x + u, y + v)''. For example if ''(u, v) = (0.5, 0.5)'',
then the sampling point of the pixel ''(0, 0)'' is at
''(0.5, 0.5)''.

Let

''dx = xEnd - xStart''

''dy = yEnd - yStart''

The algorithm separates into cases based on which
octant the end-point is with respect to the start point.
The octants are numbered as:

	\2|1/
	3\|/0
	--+--
	4/|\7
	/5|6\

### Derivation

Assume ''|dx| >= |dy|''. This takes care
of octants 0, 3, 4 and 7. We will deal
with the other octants later.

We start tracing from the pixel ''(x(0), y(0))''
that has the sampling point closest to ''(xStart, yStart)''.

From here, we perform either of the
two steps:

 1. ''x(i + 1) = x(i) + tx, y(i + 1) = y(i) + ty1''
 
 2. ''x(i + 1) = x(i) + tx, y(i + 1) = y(i) + ty2''

where ''(tx, ty1, ty2)'' is one of
''{(1, 0, 1), (1, 0, -1), (-1, 0, 1), (-1, 0, -1)}''.

We choose the one that will keep us closer to the line.
This simple procedure is repeated to trace the whole line
segment.

The distance of a pixel to the line is measured as the
distance of its sampling point to the line. Thus the
comparison to select between the two cases is:

''distance((x(i) + u + tx, y(i) + v + ty1), line) <=
distance((x(i) + u + tx, y(i) + v + ty2), line)''

If this comparison yields true, the option 1 is chosen.
Otherwise option 2 is chosen. However, this is inefficient.

Let

''a(i) = x(i) + u''

''b(i) = yStart + ((x(i) + u) - xStart) * (dy / dx)''

Then ''(a(i), b(i))'' traces out points from the line
with ''a(i)'' horizontally at the sampling points.

Because of similar triangles, we can equivalently compare the
distances of the sampling points to the line along the y-axis:

''|(y(i) + v + ty1) - b(i + 1)| <= |b(i + 1) - (y(i) + v + ty2)|''

This is much faster, but the absolute values
still block the way to an efficient implementation.

Fortunately, we see that there is still one more equivalent
comparison. Rather than comparing the distances of the two candidate points
to the line segment, we can compare the position of their
midpoint to the line segment (along y-axis):

''((y(i) + v + ty1) + (y(i) + v + ty2)) / 2 <= b(i + 1)''

''<=>''

''(y(i) + v + ty1) + (y(i) + v + ty2) <= 2 b(i + 1)''

''<=>''

''(y(i) + v + ty1) - b(i + 1) <= b(i + 1) - (y(i) + v + ty2)''

Thus, the absolute values can be removed!

Rather than comparing directly ''(left <= right)'', we compare the sign
of the difference ''(left - right <= 0)'':

''s'(i)''

''= (y(i) + v + ty1) - b(i + 1)) - (b(i + 1) - (y(i) + v + ty2))''

''= 2(y(i) + v) - 2b(i + 1) + (ty1 + ty2)''

''= 2(y(i) + v) - 2(yStart + (x(i + 1) + v - xStart) * (dy / dx)) + (ty1 + ty2)''

''= 2(y(i) + v) - 2(yStart + (x(i) + tx + v - xStart) * (dy / dx)) + (ty1 + ty2)''

''= 2(y(i) + v) - 2b(i) - 2 tx (dy / dx) + (ty1 + ty2)''

If ''s'(i) <= 0'', then we choose the option that increases ''s'(i)''.
Otherwise we choose the option that decreases ''s'(i)''.

Because ''dx'' is positive, and thus does not change the sign
of ''s''', we can as well multiply s' by dx to avoid division.

''s(i)''

''= s'(i) * dx''

''= 2(y(i) + v)dx - 2b(i)dx - 2 tx dy + (ty1 + ty2)dx''

We now notice:

If option 1 is chosen, then

''s(i + 1)''

''= 2(y(i + 1) + v)dx - 2b(i + 1)dx - 2 tx dy + (ty1 + ty2)dx''

''= 2(y(i) + v)dx + 2 ty1 dx - 2b(i)dx - 2 tx dy - 2 tx dy + (ty1 + ty2)dx''

''= s(i) + 2 ty1 dx - 2 tx dy''

Similarly, if option 2 is chosen, then

''s(i + 1)''

''= s(i) + 2 ty2 dx - 2 tx dy''

Thus the values for ''s(i)'' can be computed
incrementally. However, ''s(0)'' must be computed directly:

''s(0)''

''= 2(y(0) + v)dx - 2b(0)dx - 2 tx dy + (ty1 + ty2)dx''

''= 2(y(0) + v)dx - 2(yStart * dx + ((x(0) + u) - xStart) * dy) - 2 tx dy + (ty1 + ty2)dx''

''= 2((y(0) + v) - yStart)dx - 2((x(0) + u) - xStart)dy - 2 tx dy + (ty1 + ty2) dx''

Notice that if ''xStart = x(0) + u'' and ''yStart = y(0) + v'' 
(the start point is at a sample point), then

''s(0) = -2 tx dy + (ty1 + ty2) dx''

If in addition ''(xEnd, yEnd)'' is at a sample point,
then the whole algorithm runs on integer arithmetic.

The octants 1, 2, 5, and 6 with ''|dx| < |dy|'' can be derived
by simply exchanging ''x'' and ''y'' in all formulas.
This has the effect of reflecting the plane
w.r.t the line ''(1, 1)''.
Thus the ''sAdd1'', ''sAdd2'' and ''s(0)'' can be obtained from
the following reflection pairs by exchanging ''x'' and ''y'':

Octant 1 <-> Octant 0
Octant 2 <-> Octant 7
Octant 5 <-> Octant 4
Octant 6 <-> Octant 3

Summary
-------

''sNormal = 2((y(0) + v) - yStart)dx - 2((x(0) + u) - xStart)dy - 2 tx dy + (ty1 + ty2) dx''
''sReflected = 2((x(0) + u) - xStart)dy - 2((y(0) + v) - yStart)dx - 2 ty dx + (tx1 + tx2) dy''

### Octant 0:

''(1, 0) => sAdd1 = -2 dy''

''(1, 1) => sAdd2 = -2 dy + 2 dx''

''s(0) = sNormal + -2 dy + dx''

### Octant 1 (reflected octant 0):

''(0, 1) => sAdd1 = -2 dx''

''(1, 1) => sAdd2 = -2 dx + 2 dy''

''s(0) = sReflected + (-2 dx + dy)''

### Octant 3

''(-1, 0) => sAdd1 = 2 dy''

''(-1, 1) => sAdd2 = 2 dy + 2 dx''

''s(0) = sNormal + 2 dy + dx''

### Octant 6 (reflected octant 3) 

''(1, -1) => sAdd1 = 2 dx + 2 dy''

''(0, -1) => sAdd2 = 2 dx''

''s(0) = sReflected + (2 dx + dy)''

###Octant 4

''(-1,  0) => sAdd1 = 2 dy''

''(-1, -1) => sAdd2 = 2 dy - 2 dx''

''s(0) = sNormal + 2 dy - dx''

### Octant 5 (reflected octant 4)

''( 0, -1) => sAdd1 = 2 dx''

''(-1, -1) => sAdd2 = 2 dx - 2 dy''

''s(0) = sReflected + (2 dx - dy)''

### Octant 7

''(1,  0) => sAdd1 = -2 dy''

''(1, -1) => sAdd2 = -2 dy - 2 dx''

''s(0) = sNormal + (-2 dy - dx)''

### Octant 2 (reflected octant 7)

''(-1, 1) => sAdd1 = -2 dx - 2 dy''

''( 0, 1) => sAdd2 = -2 dx''

''s(0) = sReflected + (-2 dx - dy)''

