Remarks
=======

*.cpp *.h *.hpp *.txt *.sln *.vcproj *.py SConscript*.* SConstruct*.* license*.htm

Todo
----

- Remove Simplex and Flat.
- Replace Points with Vectors.
- Clean excess whitespace.
- Check that include guards equal file name.
- Create a test file for each source file.

What are the disabled Visual Studio warnings?
---------------------------------------------

4351
new behavior: elements of array 'array' will be default initialized

4996
'function': was declared deprecated

4251
'identifier' : class 'type' needs to have dll-interface to be used by clients of class 'type2'

4018
'expression' : signed/unsigned mismatch

4267
'var' : conversion from 'size_t' to 'type', possible loss of data

When compiling with /Wp64, or when compiling on a 64-bit operating system, type is 32 bits but size_t is 64 bits when compiling for 64-bit targets. 

4305 
'identifier' : truncation from 'type1' to 'type2'

The identifier is converted to a smaller type, resulting in loss of information.

4244
'argument' : conversion from 'type1' to 'type2', possible loss of data. 

A floating point type was converted to an integer type. A possible loss of data may have occurred.

4312
'operation' : conversion from 'type1' to 'type2' of greater size

This warning detects 64-bit portability issues. You attempted to assign a 32-bit value to a 64-bit type. For example, casting a 32-bit int or 32-bit long to a 64-bit pointer.

4224
nonstandard extension used : formal parameter 'identifier' was previously defined as a type

The identifier was previously used as a typedef. This causes a warning under ANSI compatibility (/Za).

Accessing a matrix
------------------

Different kinds of access methods are useful when
accessing a general array. This has been succesfully
solved with the use of array views. Matrix is a
special kind of a 2-dimensional array. Matrix
and vector expressions can also be thought of 
as views. The only difference between views and
expressions is that while the former are both
readable and writable, the latter are only
readable. We recognize the following useful
ways to access a matrix:

1) Matrix element (i, j) by reference.
2) Matrix as a matrix expression.
- explicitly adaptable to a const view?
=> Maybe can't do because requires cursors.
3) Matrix as an array view 
- explicitly adaptable to a matrix expression.
4) Matrix row i as a vector.
5) Matrix as a contiguous sequence of
numbers in row-major order using iterators.

Dynamic sized matrices will offer all of
these access methods. Feature 4) is problematic
to implement. In particular, one can't
return mutable references to row vectors stored
in the matrix because their size and possible aliasing
could be changed from outside, thus breaking matrix 
class invariants. The options are as follows:

Option 1) Store for each row an aliasing vector for
row data. Return only readable references to these.
Make it possible to assign a vector expression to a 
row (and column) of a matrix via a member function.

Option 2) Return copies of row aliasing
vectors. Caveat: one can't store references
to matrix row vectors. We will implement this
option.

For small fixed size matrices small memory
footprint is important. Because not all of 
the above access methods can be reliably
produced, we shall implement only the
options 1), 2) without adaptation to array views,
and 4). The feature 4) is valued more important
than feature 5). Satisfying both would need
extra memory to be implemented portably.
With fixed size matrices there is no fear
of breaking class invariants by offering
a direct mutable reference to row vectors.

Output from a function
----------------------

1) Container
=> User has to allocate the needed memory.
=> Sometimes the needed memory is not known.
=> Basic exception safety.

2) Container + swap()
=> The function allocates the needed memory.
=> Need to dynamically allocate memory
at each function call.
=> Strong exception safety.

3) Container + clear() + reserve().
=> The function allocates the needed memory.
=> Possible to avoid memory reallocation.
=> Basic exception safety.

4) Iterator range
=> User has to allocate the needed memory.
=> Sometimes the needed memory is not known.
=> Basic exception safety.
=> The user can directly write to the target
storage, avoiding one copy step.
=> How to communicate that an output parameter
should be ignored?

5) Reporting functor
=> A functor is called with an iterator
range giving the nearest neighbor-distance pairs.

Qt installation
---------------

The following is needed to get Qt to work in combination
with Visual Studio 2008 Express Edition.

1. Add the /bin directory in the qt directory to the
operating systems dll search path. 

Note: It is possible that the search path already contains
directories which contain Qt dll's (for example, MikTex). 
To avoid mixing up with these, place your directory first 
on the dll search path.

2. Run 'configure' from the Qt directory.

3. Run 'nmake' from the Qt directory. This step took me about 4h
on one machine and 2.5h on another machine.

4. Add Qt '/include' directory to the compiler's include search path.

Note: you should refer to the Qt's include files by sublibraries,
for example by: '#include <QtGui/QApplication>'.

5. Add Qt '/lib' directory to the compiler's library search path.

Note: If a normal Qt library is compiled as QtCore4.lib, then
the corresponding debug version of that library is QtCored4.lib.

Something bad about Qt
----------------------

* Qt dumps all of its stuff in the global namespace. I think
this can be changed but I can't find where!

* Some common words are reserved by the Qt as macros. These
include 'signals', 'slots', 'SIGNAL', 'SLOT', and 'emit'.

* Some Qt headers include Windows headers which have some
common words used for macros, such as 'min' and 'max'.
For example, the <QtOpenGL/QGLWidget> header does this.

* The header files are not suffixed, making them
look similar to the standard library headers. Aside from being arrogant,
this risks conflicting with the possible standard library extensions
in the future.

Forward declarations
--------------------

Forward declarations are useful in cutting down include dependencies
only if the class uses the type in its implementation _through a reference_ 
but not in its interface. Otherwise the forward declaration introduces
a burden to the user of the library to include all induced header
files and in addition the compile time is not reduced at all. This kind
of usage is very rare. Thus one should not use forward declarations at all.

Concept based programming
-------------------------

I've been trying to avoid to go concept-based in my programming.
But it seems I may have to give up on this. There are some
generic programming problems that I can't solve without.
For example: filtering the rows and columns of an image without
practically doubling the code of the algorithm.

The main reason why I want to
avoid concept based functions in C++03 is that it
lacks concept based overloading (coming up in C++09). This is in turn because
concepts imply unbounded templates. For example, consider
that I have a concept MatrixConcept, 
which acts like the Matrix class currently does. Then for
the matrix inverse I create a function 'inverse':

template <typename MatrixConcept>
MatrixConcept inverse(const MatrixConcept& matrix);

That the template parameter is unbounded creates problems
with function naming. Consider that I have a concept
for real numbers, RealConcept, and a similarly named function:

template <typename RealConcept>
RealConcept inverse(const RealConcept& number);

The two functions are named the same and can't
be differentiated in C++03. This is because the parameters only
differ in the concepts they model. Differentiating
requires concept based overloading.

To solve this problem in C++03 requires to add something
to the name: to use a namespace, a prefix or a suffix.

Then the function names become, for example:

template <typename MatrixConcept>
MatrixConcept matrixInverse(const MatrixConcept& matrix);

template <typename RealConcept>
RealConcept inverse(const RealConcept& number);

This seems redundant: after all we know
by the context which one we mean; but the compiler doesn't.

So, if you use unbounded function templates, then
name them such that they do not create overload ambiguities.

Another problem is given by associated types.
For example, now that we have:

template <typename MatrixConcept>
MatrixConcept matrixInverse(const MatrixConcept& matrix);

Instead of:
template <typename Real>
Matrix<Real> matrixInverse(const Matrix<Real>& matrix);

How do we deduce the type Real? The solution is either to
say that all Matrix:s must be classes, or use a
traits class as in MatrixTraits<Matrix>::ValueType.

Division by zero
----------------

Never use the result of dividing by zero!

Why? Because there are two kinds of zeros: +0 and -0.
If you compute 1/+0, then you get Inf. But if you
compute 1/-0, then you get -Inf!
You can never be sure which zero you are holding.
Moreover, +0 == -0. That means that without inspecting the bits
itself you can not even check it.

Some code to try:

#include <iostream>
#include <string>

using namespace std;

int main()
{
	float a = 1;
	float b = 0;
	float c = -b;
	float d = a / b;
	float e = a / c;
	
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;
	cout << "d = " << d << endl;
	cout << "e = " << e << endl;
	cout << "(b == c) = " << (b == c) << endl;
	cout << "(b < c) = " << (b < c) << endl;
	
	string tmp;
	getline(cin, tmp);
	
	return 0;
}

Matrices, vectors, points and tuples
------------------------------------

Problem: should the data of fixed-size versions be stored on stack or free memory?

Requirement 1: able to return matrices from functions and still be efficient

For example, "m = transponate(xRotation(0.3))". Temporaries
generated by functions are very convenient. However, if the matrix data
is stored in stack, there is only one way to transmit the temporary 
information to m: copying, which is very slow for big matrices.

Solution 1: reference semantics. 
=> Implies using dynamic allocation and
this is inefficient for small matrices, vectors etc.

Solution 2: Use value semantics for small objects, but reference semantics for large objects.
=> Large objects act similar to shared_ptr
=> Now "Matrix a; Matrix m(a); a *= 2;" has different results for small and large matrices which
is confusing. Copy construction must be a reference-copy, not value-copy because that
is the essential efficiency requirement for returning from functions.

Solution 3: Use move semantics..
=> Large objects act similar to auto_ptr
=> Subclass Matrix with Matrix. Matrix's allow
move semantics when assigned. Return Matrix's from functions.
=> Nice solution for one class alone, but does not layer nicely.
E.g. take a Box, which contains a Matrix. Move semantics for the Box
again needs Box etc: its hard work.

Matrix indexing
---------------

It is standard to index a matrix A as A[y, x], where y gives the row and x the column.
Also, it is standard to use column vectors, because then the matrix-vector multiplication
Ax resembles function evaluation A(x). Given the column vector convention, the
column vectors of the matrix are the ones of importance because they represent
the images of the standard basis vectors. For a programmer it is very convenient to refer to the
column vectors as a whole. A natural notation for this is A[x], where x gives
the column. However, now A[x][y] and A[y, x] refer to the same element
which is likely to cause confusion because the indices come at a different order!
This discrepancy can be corrected by either:

1) indexing matrices as A[x, y] 
2) prohibiting column vector references
3) switching to row vector convention

The option 1 will not do because it would create more confusion 
than it corrects by diverging from a world-wide standard.
The option 2 will not do because it is of too great importance 
for the usability of the library.
The option 3 will create some confusion because most have
been used to work with column vectors. However, the connection
between using column or row vectors is trivial.

Thus in this library we will use the row vector convention.

Consequences:
=> You lose the functional style notation for matrix-vector multiplication,
because otherwise you have: x * A * B = B(A(x))
which is again confusing because the A and B come at different order.
=> You can't use this for affine transformations either, because
you want an analog between them and matrices (because linear transformations form
a submonoid of affine transformations). Let A and B be matrices and
A' and B' their corresponding affine transformations. For analogy you need: 
x * A * B = x * A' * B'. B'(A'(x)) would again be confusing.

Transponation in Array
-----------------------

To solve for the problem of reusing horizontal 2d resampling for vertical resampling, 
I made a transponate() function to the Array class. This function toggled an inner flag. 
If the flag was on, width() would return the height of the array, and height() would return 
the width of the array. Similarly data access indexing was changed. In effect this was a 
constant time transponation.

Lesson to be learned: 
While it works nicely for non-const Array's, it doesn't work for the const ones 
(reading from an array in a transposed manner).

Complex concepts
----------------

Concepts will be an impressive addition to the C++0x, but currently implementing and using 
such code is a pain. The most important thing contributing to this is that there is no 
concept based overloading. Another is that defining and checking the concept requirements 
via Boost is quite cumbersome.

Lesson to be learned:
In C++03, do not create complex concepts.

Bug with placement new
----------------------

I spent two days debugging a bug caused by writing:
new(data) HalfData
instead of the correct
new(data) EdgeData

The symptoms were plain illogical. Note that the type of 'data' was
EdgeData*, but since the placement new takes a void pointer,
there was no type error.

Lesson to be learned:
Double-check your placement news.

Implementing static virtual functions
-------------------------------------

Summary:
* In the base class, declare constructors, assignment, and destructor protected.
=> Protected constructors imitate the workings of a pure abstract class.
Protected assignment protects from slicing and protected destructor protects
from destructing a derived object through a base object reference.
* Declare the base class a friend of the derived class.
=> This way you can declare private static virtual functions.
* Do not use static virtual functions in the base class constructors or destructor.
=> For the same reasons as with real virtual functions.

_SECURE_SCL
-----------

I spent a week hunting a bug which had something to do with memory. I had access 
violations and plain illogical behaviour. The symptoms occurred only in release mode, 
not debug mode. The bug was in Visual Studio and caused by the feature _SECURE_SCL 
which can be turned off. I already had this done with other projects, but I forgot 
to turn the feature off in one project.

Lesson to be learned:
Remember to turn off _SECURE_SCL and (checked iterators) in every project. 
In project properties -> C++ -> Command line, write
/D "_SECURE_SCL=0" /D "_HAS_ITERATOR_DEBUGGING=0"

Entertaining bug
----------------

An extraneous ; was inserted at the code at some point.
It compiled and resulted in a never-ending loop.

template <int Height, int Width, typename Real>
Matrix<Height, Width, Real> randomMatrix()
{
	Matrix<Height, Width, Real> result;
	for (integer i = 0;i < Height;++i)
	{
		for (integer j = 0;j < Width;++j)
		{
			result;(i, j) = random<real>() * 2 - 1;
		}
	}
	return result;
}
