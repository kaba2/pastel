PointKdTree class
=================

[[Parent]]: multilevel_kdtree.txt

Practice
--------

The PointKdTree class is a data structure that allows storing
and manipulating a multi-level kd-tree efficiently.
This data structure has been primarily designed for efficient
nearest neighbor searching in static and semi-dynamic point-sets.
It is declared as:

[[CppCode]]:
	template <typename Real, int N = Dynamic, 
		typename PointPolicy = Vector_PointPolicy<Real, N> >
	class PointKdTree;

where N is the dimensionality of the tree, Real is a computation
type which models an ordered field, and PointPolicy is a policy
class which allows to store the points in different ways.
The dimensionality can be set to Dynamic meaning that it is chosen 
at runtime. The PointPolicy concept will be detailed later below,
because most of the time you will probably find the predefined policies
satisfactory. Since the stored objects might be indirect representations 
of points, they are called _objects_ instead.

### Predefined object policies

 * *Vector_PointPolicy\<Real, N\>* class stores as objects 
 elements of type Vector\<Real, N\>, thus representing points directly.
 
 * *Array_PointPolicy\<Real, N\>* class stores as objects
 pointers to Real. These pointers should point to the beginning of
 a Real array containing the point coordinates. Again it is assumed that
 the memory pointed to has been allocated memory elsewhere. Using
 this object policy can be advantageous because it can easily interface 
 with external software and avoids problems with possible abstraction 
 penalties which might exist when using the Vector\<Real, N\> class.

### Traversal of the subdivision using cursors

The nodes of the kd-tree can be traversed using cursors. 
From each node you can traverse either to a parent (if it exists) 
or to left or right child (if they exist). At each node you can inspect:

 * How many objects are stored under the sub-tree whose root-node 
 the current node is?
 
 * What those objects are? (iterator range to the object list).
 
 * What are the node bounds on the splitting dimension?
 
 * What are the cursors to the child nodes?
 
 * What is the cursor to the parent node?

### Traversal of the objects in the kd-tree

All of the objects stored in the kd-tree can be traversed as a
sequence using an iterator interface. Note that their order
can change after subdivision, and if an object is removed and
immediately inserted back, it might take another position in 
the object list.

### Insertion of points

Points can be inserted into the tree at any time, either one
by one or as a set. No new nodes are created in this process.
However, the kd-tree automatically adapts to higher resolution
when it updates the positions of the bucket nodes.

### Removal of points

Points can be removed from the tree at any time. This can be
done either one by one, or by removing all points at once.

### Refinement of the subdivision

The recursive subdivision of the kd-tree can be refined
at any time. In this process existing leaf nodes are converted
into split nodes by recursively subdividing them into two new leaf 
nodes. The split plane is chosen by a _splitting rule_.

### Parent nodes for up-traversal

In addition to being able to traverse the tree from the
root to the leaves, PointKdTree allows you to move from
a child to its parent. 

### Node bounds on the splitting axis

Each split node contains the bounds of the node on
the splitting axis. Knowing these bounds is essential in
the implementation of an efficient nearest neighbor
searching algorithm.
