KdTree design decisions
=======================

Invariants
----------

- Every object inside a kdtree is contained in the bounding box of the kdtree.
- An object is listed in a leaf node if and only if its bounding box intersects with
the bounding box of the leaf node.
=> This guarantees that the objects are distributed in the tree leaves by geometry

How to use the data structure?
------------------------------

As always, algorithms should not be placed inside the class implementing the kdtree.
For example, it should _not_ have a function that subdivides the kdtree
using the surface area heuristics. Instead, it should have a member function to 
subdivide a leaf node once with a given plane. Likewise it should not have a member function
for ray traversal. There are many subdivision heuristics and ray traversal
algorithms. These are algorithms that operate on a kdtree, not integral parts
of a kdtree.

=> make it possible to traverse and modify the kdtree from outside => cursors
=> implement algorithms in terms of these basic functionalities

How to support different kinds of objects (genericity)?
-------------------------------------------------------

Solution 1: an object oriented interface
----------------------------------------

class KdtreeObject
{
public:
	virtual ~KdTreeObject()
	{
	}
	
	virtual AlignedBox<N, Real> boundingBox() const = 0;
};

=> can result in performance losses for single concrete types because of
dynamic binding

Solution 2: by generic programming
----------------------------------

Store arbitrary data and require to supply functors
that return the bounding box and the projection to an axis.

template <int N, typename Real, typename Object,
typename ProjectionFunctor, typename BoundFunctor>
class Kdtree
{
//...
};

=> efficient for concrete types
=> supports sharing of data (for example, store indices to a vertex buffer)
=> you can still use polymorphic objects (for example Object = KdTreeObject*)
=> A bit too many parameters

Solution 2: generic programming with a policy
---------------------------------------------

template <int N, typename Real, typename ObjectPolicy>
class KdTree
{
};

class ObjectPolicy
{
public:
	typedef int Object;
	
	AlignedBox<N, Real> bound(const Object& object) const;
	Tuple<2, Real> bound(const Object& object, integer index) const;
};

How to place an object in a node?
---------------------------------

About the geometry. 
You can place an object into a node by its exact geometry. But this can lead to numerical problems
(consider a triangle). The bad situation occurs if an object does not get included in a node while it overlaps it.
Then again, if the object is in a node but does not actually overlap it, this just reduces
performance but does not give incorrect results. So you need to insert the object by a reasonable bounding volume. 
An axis aligned box is free of numerical robustness problems, simple and not too unefficient a bounding volume.

=> place object to the kdtree by its axis aligned box

About an interface issue. To preserve the bounding box invariant,
the interface to add an object in the kd-tree should be on the kd-tree level,
not on the node level.

Should it be possible to incrementally insert more objects?
-----------------------------------------------------------

=> yes, no problem. 
=> the user must remember to keep the data structure optimal by local or global 
subdivision.

Should it be possible to remove objects from the structure?
-----------------------------------------------------------

- you need to remove the object from all cells it overlaps
- finding the cells is a no-problem
- however removing the objects from the leaf node object lists
is a seemingly slow (linear) operation
=> the efficieny depends on the number of leaf nodes it covers
=> at every leaf node we can assume to be dealing
with a small constant amount of objects (of course
this assumption can fall in some situations)
=> it's not that bad

=> yes, why not.

How should you deal with changing geometry?
-------------------------------------------

- because you can actually be holding only references to the geometry data,
it is possible for the user to change geometry without the kd-tree
knowing about it.
=> this is the price to pay for being able to share object geometry
=> this can invalidate both invariants of the kdtree, not good
=> for example object removal won't then work in general
=> this can only be prevented by prohibiting it in documentation
=> you can get into same kind of trouble with std::set (for example) by using
pointers as keys and comparing by their values

- whenever the user wishes to change geometry, he should
do it by removing the object, changing the geometry of the object and
inserting the object back.

- if all/many objects are changed then it would be nice to:
=> make it possible to clear out objects, but not clear out the subdivision
=> when the objects move and/or deform, the tree gets worse and worse
a representation of the object distribution. eventually the user should
do a full refitting.

How should you store the objects?
---------------------------------

- in an array: then you would give an interval in this array for each leaf node
=> but if you permit incremental addition of objects, then the objects must be
added in the middle of the array. not only is this slow but also destroys
the references. Thus an array is not an option.

- in a linked list: creating a linked list for each leaf node is wasteful.
a better idea is to share a single linked list for all leaf nodes using
inclusive iterator ranges (ranges of the form [a, b], rather than the usual [a, b[).
- why inclusive ranges? because the object that is pointed to by an end-iterator
of a normal range can get removed.

=> Use a shared linked list for all leaf object lists. 
=> In leaf nodes, use inclusive iterator ranges.

How should you store the nodes?
-------------------------------

- use an array to store nodes
=> at times the array memory will be reallocated
=> therefore indices must be used as children references
=> but this increases indirection in node traversal
=> it can be problematic if the reallocation happens in the middle
of a recursive function call (subdivision) invalidating node pointers at
previous levels
=> sounds like a bad idea

- allocate each node dynamically and persistently
=> you can avoid allocation overhead by using a PoolAllocator or ArenaAllocator.

Should you allow intermediate nodes to have less than two children?
-------------------------------------------------------------------

- If there are no objects in the negative child of an intermediate, 
you can either create an empty leaf node or give a null reference to
the intermediate node.
- However, empty leaf nodes are helpful when you want to
subdivide, because then you can explicitly point to the node
you want to subdivide.
- With null references you have to be indirect from the parent:
"subdivide the negative child of this node"

=> Intermediate nodes should always have two children.

What information do you need in nodes?
--------------------------------------

Leaf node:
- element count (4 bytes)
- start position in the object list (4 bytes)
- last position in the object list (note inclusive range) (4 bytes)
- leaf bit (1 bit)

Normal node:
- pointer to negative child (4 bytes)
- pointer to positive child (4 bytes)
- splitting position (4 bytes)
- splitting axis (3 bits, giving you dimensions up to 8)
- leaf bit (1 bit)

Leaf bit differentiates between leaf nodes and normal nodes.
Because memory is allocated on at least 4 byte alignment,
you can store data in the two least significant bits of
the pointers. For normal nodes, use this storage for
the splitting axis and the leaf bit. For leaf nodes, you
can store the leaf bit along with the element count.
For dimensions higher than 8 you must allocate an additional
byte for the splitting axis.

This amounts to 12bytes per node for dimensions <= 8,
and 13 bytes (padded to 16?) per node for dimensions > 8.

=> Packing data this way is very significant since in general there will 
be lots of nodes.

Should the kd-tree know its bounding box?
-----------------------------------------

- a bounding box for the tree maintains the invariant that the objects in the tree are contained in it
- the bounding box is frequently needed (for example for splitting criteria and ray traversal)
- at object insertion this bounding box must updated
- this has the effect of enlarging the boundary voxels.

=> make it possible to enlarge the bounding box but not shrink it
=> inserted objects enlarge the bounding box automatically

Should you use the same data structure for points and arbitrary shapes?
-----------------------------------------------------------------------

This is possible. However:
1) The shapes have to be abstracted by their bounding aligned boxes.
=> Point based implementation suffer some abstraction penalty.
2) The splitting bounds in the nodes are needed by nearest neighbor
searching with points but are not needed in ray tracing.
3) The splitting bounds imply that one can't refine per node
(but per tree, see 'implementation experience').

It seems a better alternative is to create:
* a kd-tree that is designed for ray tracing (KdTree)
* a kd-tree that is designed for point sets (PointKdTree)

With PointKdTree, should we actually implement
PointBspTree, which can be customized to either kd-tree or 
diagonal bsp tree? No, again node bounds do not make sense for 
diagonal bsp tree.

PointDbspTree

Implementation experience
-------------------------

- The packing of nodes induces some performance degradation.
- Efficient approximate nearest neighbors requires to store
intermediate node bounds in the split dimension.
- Storing the node bounds in the split dimension implies
that the user can't be allowed to subdivide a node through
a cursor since the node bounds can not be found out
efficiently. 
- Instead, you implement a member function
that refines the kd-tree with a user-defined splitting rule.
This way you keep the kd-tree nodes having the correct
node bounds.
- In nearest neighbor searching and refinement, recursive 
function calls are faster than iteration based on a stack.
- In nearest neighbor searching, performance is enhanced
by computing partial distances: whenever the distance
computation exceeds the current culling distance, the
computation can be aborted.
- In nearest neighbor searching, performance is enhanced
by computing with norm bijections rather than norms
(for example, squared L2-norm).

