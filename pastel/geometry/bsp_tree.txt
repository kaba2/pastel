BSP trees
=========

[Parent]: data_structures.txt

Theory
------

### BSP-tree

A _binary space-partitioning tree_ or a BSP-tree, 
is a binary tree whose nodes correspond to closed convex sets in ''RR^n''. 
Denote the corresponding shape of a node ''A''
by ''s(A)'' and extend this notation to sets by 
''s({T_1, ..., T_n}) = {s(T_1), ..., s(T_n)}''.
The terminal nodes are called _leaf-nodes_, 
while the non-terminal nodes are called _split-nodes_. 
Given a split-node ''A'', the children of the node are formed
by dividing ''s(A)'' with a plane into two almost-disjoint closed convex shapes.
This plane is called the _splitting plane_.

Let ''T'' be a BSP-tree. Denote the set of leaf-nodes of ''T''
by ''{T}''. Let ''S'' be a subtree of ''T'' such that ''S'' and ''T'' share
the same root node. Then it holds that ''s({T})'' is a partition 
of ''s(S)'' (a _partition of ''s(S)''_ is a collection of disjoint sets 
which cover ''s(S)''). Furthermore, let ''S_2'' be a subtree of ''T'' such
that they share the same root-node, and let ''S'' be a subtree
of ''S_2''. Then ''s({S_2})'' is a refinement of ''s({S})''.

### Point BSP-tree

A _point BSP-tree_ is a pair ''(T, P)'' such that ''P'' is a finite point 
set in ''RR^n'' and ''T'' is a BSP-tree such that ''P sub s(T)''. 
A node ''L in T'' is said to _hold_ a point ''q in P'' if ''q in s(L)''. 
The set of points that a node ''L'' holds is denoted by ''p(L)''.

Given a bucket size ''M'', a _bucket node_ is a node which is either

 * a leaf node which holds more than ''M'' points, or
 
 * a node which holds at most ''M'' points, but whose parent 
 (if not the root node) holds greater than ''M'' number of points. 
 
### Kd-tree

A _kd-tree_ is a special kind of a BSP-tree, with the restriction
that each splitting plane is orthogonal to some standard basis axis.
We further restrict the definition so that the subdivided region
is an axis aligned box. The advantage of this restriction is
that the the subdivided parts of the space are also axis aligned 
boxes.

Practice
--------

A BSP-tree makes it possible to design efficient algorithms for several 
geometric problems. Such problems include ray casting, nearest
neighbor searching, and range searching. The efficiency of these
algorithms rely on the ability to skip exploring a large part 
of the space if that is known not to affect the result. The BSP-tree
is effectively a multi-dimensional generalization of the binary tree.
In practice, it is the kd-tree which offers the best properties
of the BSP-trees, from many point of views. We will summarize these
properties shortly.

Pastel implements the PointKdTree class to handle point kd-trees. 
In particular, this data structure can be used for efficient 
nearest neighbor searching. In Pastel, this is the main use for the
PointKdTree. For a kd-tree suitable for ray casting, see the links below.

Kd-tree vs BSP-tree
-------------------

Restricting the splitting planes to be orthogonal with the standard
basis axes has a number of advantages. Some of these are:

 * A plane can be described by one integer 
 (the splitting axis), and one real number 
 (distance of the plane from the origin).
 In contrast, arbitrary planes require ''O(n)''
 storage in ''RR^n''.

 * It can be tested with a single comparison on which
 side of the splitting plane a point is. Because there
 is no arithmetic involved, there are no numerical 
 problems with rounding: the result is exact.
 In contrast, arbitrary planes require ''O(n)'' time in ''RR^n'',
 and the result might be wrong due numerical problems.

 * For nearest neighbor searching, there are
 splitting rules which are easy to compute and result
 in excellent performance for the nearest neighbor
 searching. In contrast, with arbitrary planes, to the
 best of our knowledge, there is currently no known 
 splitting rule that would have both of these properties.
 
 * When doing nearest neighbor searching,
 with orthogonal splitting planes and an axis-aligned 
 box as the region, there is a technique to incrementally 
 compute the exact distance from the search point to the 
 partition cells. This allows for more efficient culling 
 of space which in turn increases performance. In contrast, 
 this is very hard to achieve with arbitrary splitting planes.

