Implementation blog
===================

Property sheets for 64-bit platform
-----------------------------------

16.6.2012

After adding the x64 platform to the project in Visual Studio 2010 SP1, 
the property sheet Microsoft.cpp.x64.user was not created for the 
projects. This was resolved by restarting the Visual Studio.

A summary of C++11 state in Visual Studio 2010
----------------------------------------------

xx.06.2012

Of highest interest, and complete:

 * auto
 * right-angle brackets
 * static_assert
 * trailing return types
 * nullptr

Of highest interest, and usable:

 * rvalue-references
 * lambdas
 * override

Of highest interest, but works incorrectly:

 * decltype

The features listed up to this point are the
ones we will have to work with.

Of highest interest, but not available:

 * initializer lists
 * default function template arguments
 * alias templates
 * strongly typed enums
 * noexcept
 * variadic templates

Of interest, but not available:

 * explicit conversion operators
 * forward declared enums
 * range-based for loop
 * delegating constructors
 * inheriting constructors
 * default and deleted functions
 * char16_t and char32_t
 * unicode string literals
 
Implementation details affecting interface
------------------------------------------

07.06.2012

Inside a data structure I have something like this:

	typedef std::multimap<NonTerminal_ConstIterator, Rule, 
		Pastel::Iterator_Less> RuleSet;

Using the map gives a fast access to Rules based on a 
NonTerminal key. I will then expose an iterator- or range-based
interface directly to RuleSet.

### Problem

The user of the data structure is only interested
in the set of Rules, not in NonTerminal-Rule pairs. The pairs
make the interface uncomfortable to use. How to expose only
the Rule-part?

## Solution 1: Iterator facade

Rather than exposing direct iterators to the RuleSet,
expose a facade iterator which gives access only to the Rule-part
of the pair.

Extending hashing
-----------------

19.8.2011

Consider the function

[[CppCode]]:
	template <typename Range>
	void f(Range range)

Assume `f` requires the value-type of range to be hashable.
If this isn't the case, how should this be made to work?

### Option 1

Add the hash function as an argument of `f`.

Naming of concept models
------------------------

19.8.2011

Currently we name the models of a concept (and derived classes of an 
abstract class) in the form `Array_Range`, where the modeled concept 
is given by `Range`. Assume the `Range` concept has a refinement
`IndexableRange`, and that `Array_Range` also models the 
`IndexableRange` concept. Should we then rename `Array_Range` as
`Array_IndexableRange`? That is, should the suffixed concept be the
weakest, or the strongest concept the type models?

To keep the names short, I think the naming should be by the weakest 
concept, i.e. `Array_Range` in this case.

Naming of ranges
----------------

19.8.2011

Currently the ranges are named `ForwardRange`, `BidirectionalRange`,
and `RandomAccessRange`. The names are a bit too long. Could we find
shorter names? Some naming suggestions follows:

### Forward ranges

 * ForwardRange (no: every range is forward, so it is redundant)
 * Range
 
### Bidirectional ranges

Best ones:
 
 * BidirectionalRange (no: too long)
 * DuplexRange (no: duplex term may not be well-known)
 * BidiRange (no: non-standard abbreviation)
 * ReversibleRange
 
Others:

 * TwoWayRange (no: don't like two-part names)
 * BiRange (no: confused with two parallel ranges)
 * LeftRightRange (no: don't like two-part names, looks bad)
 * BothRange (no: uninformative)
 * ListRange (no: confused with only being applicable to std::list)
 * LinkedRange (no: forward ranges are also linked, uninformative)
 * LinkRange (no: forward ranges are also linked, uninformative)
 * DoubleRange (no: confused with two parallel ranges)
 * ChainedRange (no: uninformative, forward ranges are also chained)
 * SequentialRange (no: forward ranges are also sequential)
 * SequenceRange (no: forward ranges are also sequences)
 * NeighborRange (no: uninformative, graph nodes have neighbors too)
 * AdjacentRange (no: uninformative, graph nodes have adjacencies too)
 
### Random access ranges

Best ones:

 * RandomAccessRange (no: too long, two-part)
 * IndexedRange (yes: like an indexed set, no: indexable, not indexed)
 * IndexableRange 

Others:
 
 * RandomRange (no: confused with random values)
 * ArrayRange (no: confused with only being applicable to arrays)
 * VectorRange (no: confused with only being applicable to std::vector)
 * CompleteRange (like in a complete graph, no: not recognized)

### Extensions to iterators

The names of the ranges should extend nicely to iterators.

 * Iterator
 * ReversibleIterator
 * IndexableIterator
 
This also gives a nice 'associativity of names':

 * Iterator_Range ~ IteratorRange
 * ReversibleIterator_Range ~ Reversible_IteratorRange
 * IndexableIterator_Range ~ Indexable_IteratorRange

Transmitting a set of pairs generically
---------------------------------------

17.8.2011

The problem is to transmit a set of pairs as an input to a function.

### Option 1

Transmit two sequences of equal length, the other corresponding
to the first elements of pairs, and the other to the second elements
of pairs.

### Option 2

Transmit a sequence of a known type, and require from the type a
similar interface as some concrete type, such as std::pair.

### Option 3:

Transmit a sequence of pairs, and an object to extract the elements
of each pair.

Superclass delegation
---------------------

14.7.2011

Say that Logger is an abstract class. A Logger can be attached
as an observer to a (unique) Log object. Let us require that
whenever an object with a type of a subclass of Logger is 
destructed, it reports this beforehand to its corresponding Log 
(if it exists). This means that each Logger object must store
a pointer to the associated Log object. On the other hand,
each subclass of Logger must remember to report the destruction
to its Log.

If each subclass has to implement this reporting manually,
the same functionality is implemented over and over again,
which is redundant. On the other hand, the feature is
not at all specific to the subclasses and can be completely
implemented in the Logger superclass. This begs for factoring 
the functionality out of the subclass into the Logger class.
But are there problems with such a factoring?

It is perfectly valid to have concrete functions
implemented by the Logger, perhaps built using the abstract 
functions. However, how about member variables in an abstract
superclass? This results in the need for 'superclass delegation',
which is that constructors, copy constructors, and assignment
operators _must_ remember to call their superclass correspondences,
an operation which is otherwise not needed (since the superclass
has no state). This is again a redundancy, perhaps well described
as 'superclass delegation', which the implementor of the subclass 
might forget to do with unfortunate consequences.

The choice is then between two redundancies: 'superclass delegation'
or 'reimplementation of a features common to all subclasses'.
Between these two, the 'superclass delegation' is a better
option. The reasons are that

 * The common functionality can be varied, if needed, without much
 effort. This option is not practically available when the 
 functionality is replicated to all subclasses.
 
 * The superclass delegation approach scales with the increasing
 complexity of the common functionality.

Invasive reference counting
---------------------------

2.7.2011

In general, invasive reference counting (e.g. via `CountedPtr`) suggests 
that the counted objects should not be allocated in the stack. 
But whether the lifetime of an object should be decided by the amount of 
references or automatically by the stack, is object-dependent, and thus 
should not be decided on the class level.

_Pastel should get rid of `CountedPtr` and move on to use C++0x 
`shared_ptr` as needed._

Reference-counted pointers
--------------------------

2.7.2011

The `Log` class redirects its output to attached observers, called
`Loggers`. The `Log` is itself a `Logger`, to allow for composition.
The loggers are attached by reference. Should `Log` accept these
references as raw pointers, or as reference-counted pointers?
The problem here is that with raw pointers the references can become
invalid if the referred objects are destructed. A bit of reflection 
shows that the actual problem is to consider different options on 
what should happen when an observer object is destructed.

### Option 1: dangling references

After an observer object is destructed, the references to it
become invalid. Subsequent use of the observer object then cause 
a crash or similar. Avoiding crashes requires the user to detach 
the observer before destruction. As always, leaving something 
to a human's responsibility is a bad idea.

### Option 2: shared ownership

With reference counting, the observer is destructed only when the 
references to it goes to zero. If the `Log` has a reference to the 
observer, the observer is never destructed before detachment. This 
is shared ownership. It is not clear though that the `Log` should 
have such an ownership privilege. This forces the users of `Log`
to allocate loggers dynamically and store them in the smart pointer
given in the interface of `Log`.

### Option 3: automatic detachment on destruction

When a logger is destructed, it is automatically detached from the log. 
This requires that each log knows its loggers, and that each logger knows 
its logs. This makes the lifetimes of logs and loggers independent. As a 
simplification, it could be useful to restrict the number of attached-to 
logs to one. 

