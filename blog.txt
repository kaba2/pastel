Implementation blog
===================

Redundancy and abstraction
--------------------------

The golden rule of abstraction:

	If there exists two or more pieces of text, written in a language S,
	for which you can easily describe an algorithm by which they are 
	similar, then either the language is lacking an abstraction 
	mechanism, or the mechanism is not taken advantage of.

In this rule, if the abstraction mechanism exists, but is hard to use,
this also counts as lacking.

Disabling iterator checking in Visual Studio 2010
-------------------------------------------------

19.06.2012

In Visual Studio 2010, the preferred way to disable
iterator checking is to define `_ITERATOR_DEBUG_LEVEL = 0`.
The `_ITERATOR_DEBUG_LEVEL` replaces the different
combinations of `_SECURE_SCL` and `_HAS_ITERATOR_DEBUGGING`. 
See [here][DebugIterator] for more information.

[DebugIterator]: http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Stephan-T-Lavavej-Advanced-STL-3-of-n

Build switches
--------------

18.06.2012

I am seeing two approaches to implementing library-wide 
build switches, of which both are problematic. These are

### As header file switches

In this approach the build switches are located in a such
.h file which is included in every file in the library,
i.e. `environment.h`. In this file the appropriate 
preprocessor defines can be set to the desired values, 
e.g. `#define PASTEL_DEBUG_MODE 1`, before the build.

The problem with this approach is that each configuration
of the library (e.g. debug and release) needs a different
set of these defines. Setting the switches in a header 
file does not work well with build tools where you can
select any configuration to build.

### As compiler switches

In this approach the build switches are given to the
compiler when building the library, e.g. 
`/DPASTEL_DEBUG_MODE`. This will avoid the problems with
the header file approach. However, it then creates new 
problems. Consider a library B using a library A.
Then the library B needs to remember the build switches 
that were used to build the library A and use those same
switches to build B, in addition to its own build switches.
In general, if there are n libraries in a sequence, then 
the m:th library needs to remember m build switch sets. 
Clearly this approach does not scale well.

### Checking for ABI-incompatible switches

Visual Studio 2010 introduces the pragma 
`detect_mismatch`, which can be used as follows.

[[CppCode]]:
	#pragma detect_mismatch("PASTEL_VERSION", "1.3.0")

It creates a key-value pair which is embedded into each
object file whose translation unit contains this pragma.
If the object file is later linked together with another
object file with a differing value for the same key,
it is reported as a linker error. In addition to the
version numbers of libraries, we should check each 
ABI-incompatibility-causing build switch in this way,
such as the `PASTEL_LARGE_INTEGER`.

Property sheets in Visual Studio 2010
-------------------------------------

18.06.2012

Property sheets are a nice way to set up properties to
projects. Each property sheet is a collection of properties
for a project. One can attach arbitrarily many property
sheets to each project, and the property sheets can be
shared between projects. The latter feature is the
essential one.

In my solutions at least, the projects share very similar
properties. Now I can create just one property sheet for
the whole solution and apply that to each project. If I
want to change the properties, I will do so in the property
sheet.

What's more, multiple property sheets can be layered so
that the union of their properties applies. The sheets
are given an order. If two sheets define the same property,
then the later one takes priority.

The strategy is to give each solution a property sheet
in which to configure output directories, disable warnings,
and disable secure-stl etc. You will then make this
property sheet part of your solution, in the sense of 
carrying it around in the version control.

There are also special global property sheets called
`Microsoft.Cpp.Win32.user` and `Microsoft.Cpp.Win64.user`
which are automatically added to each configuration of
each project. These will apply properties globally on _your_ 
computer. If you change to another computer, these settings 
are lost. These property sheets are ideal for specifying 
include and library directories for external libraries
(which are of course computer-specific). While the former 
works on 32-bit builds, the latter works on 64-bit builds. 
Of course, you will want to choose different directories 
for them.

A bit odd feature of the property sheets is that they won't
get save automatically when you change a property. You must
either Save All, or right click on the property sheet and
save it. This is unintuitive and causes unnecessary confusion
from time to time.

It is useful to notice that a property sheet can be added to
all projects and configuration at the same time. Simply select
the desired projects or configurations and right click to
add an existing property sheet. Unfortunately, it seems a 
given property sheet can not be removed from all projects
at once.

If you need to set project-specific properties, do note that
you must explicitly bring in the inherited properties.
For example, in the Preprocessor definitions property,
this is done by `%(PreprocessorDefinitions)`.

There is a trap in the command-line settings. If you specify
`Additional Options` in a project, then those will not be 
unioned with the additional options in the property sheets.
Unless I am mistaken, it is missing a way to bring in the 
inherited options. Therefore, you should use the other options
explicitly instead. For example, if you need a preprocessor
definition, do it in the Preprocessor definitions property
instead of as a `/D` switch in Additional Options.

Bison and flex
--------------

18.06.2012

In Gnu Flex, we would like the scanner not to include the unistd.h 
file because it is not a standard file and does not exist on Windows.
Later versions of Flex have the `%option nounistd`. Unfortunately
the latest Flex version that can be found for Windows is 2.5.4
and it does not have this option. It is sufficient to create an
empty unistd.h file. However, creating the file in the current
directory will not do, because it is included as <unistd.h>,
that is, the current directory will not be searched.
It has to be placed somewhere on the include search path of the
compiler.

The lexer can be generated by:
flex -olex_console_scanner.cpp console_scanner.l

In Visual Studio, you can make this automatic as a custom
build step. Right click on console_scanner.l, click on
Properties, and give the above as a custom build command.
Interestingly, the above does not work if the -o option
is on the right side. Also note that it is essential to
change the name of the output file to .cpp. Otherwise flex 
will output a .c file, which will be compiled as C code by
Visual Studio. This will give errors since the code is
actually C++.

Mercurial SSL-certificate
-------------------------

17.06.2012

While pushing changes in TortoiseHG, it said that
"SSL: Server certificate verify failed". The problem
is that the certificate in the server is self-signed.
Two ways to fix this:

1) Add to mercurial.ini (Global Settings --> Edit file)

	[web]
	cacerts=

2) or, in the Synchronization window of TortoiseHg,
   push the lock-icon to get to the security options,
   and then select "No host validation.".

Property sheets for 64-bit platform
-----------------------------------

16.06.2012

After adding the x64 platform to the project in Visual Studio 2010 SP1, 
the property sheet Microsoft.cpp.x64.user was not created for the 
projects. This was resolved by restarting the Visual Studio.

A summary of C++11 state in Visual Studio 2010
----------------------------------------------

xx.06.2012

Of highest interest, and complete:

 * auto
 * right-angle brackets
 * static_assert
 * trailing return types
 * nullptr

Of highest interest, and usable:

 * rvalue-references
 * lambdas
 * override

Of highest interest, but works incorrectly:

 * decltype

The features listed up to this point are the
ones we will have to work with.

Of highest interest, but not available:

 * initializer lists
 * default function template arguments
 * alias templates
 * strongly typed enums
 * noexcept
 * variadic templates

Of interest, but not available:

 * explicit conversion operators
 * forward declared enums
 * range-based for loop
 * delegating constructors
 * inheriting constructors
 * default and deleted functions
 * char16_t and char32_t
 * unicode string literals
 
Implementation details affecting interface
------------------------------------------

07.06.2012

Inside a data structure I have something like this:

	typedef std::multimap<NonTerminal_ConstIterator, Rule, 
		Pastel::Iterator_Less> RuleSet;

Using the map gives a fast access to Rules based on a 
NonTerminal key. I will then expose an iterator- or range-based
interface directly to RuleSet.

### Problem

The user of the data structure is only interested
in the set of Rules, not in NonTerminal-Rule pairs. The pairs
make the interface uncomfortable to use. How to expose only
the Rule-part?

## Solution 1: Iterator facade

Rather than exposing direct iterators to the RuleSet,
expose a facade iterator which gives access only to the Rule-part
of the pair.

Extending hashing
-----------------

19.8.2011

Consider the function

[[CppCode]]:
	template <typename Range>
	void f(Range range)

Assume `f` requires the value-type of range to be hashable.
If this isn't the case, how should this be made to work?

### Option 1

Add the hash function as an argument of `f`.

Naming of concept models
------------------------

19.8.2011

Currently we name the models of a concept (and derived classes of an 
abstract class) in the form `Array_Range`, where the modeled concept 
is given by `Range`. Assume the `Range` concept has a refinement
`IndexableRange`, and that `Array_Range` also models the 
`IndexableRange` concept. Should we then rename `Array_Range` as
`Array_IndexableRange`? That is, should the suffixed concept be the
weakest, or the strongest concept the type models?

To keep the names short, I think the naming should be by the weakest 
concept, i.e. `Array_Range` in this case.

Naming of ranges
----------------

19.8.2011

Currently the ranges are named `ForwardRange`, `BidirectionalRange`,
and `RandomAccessRange`. The names are a bit too long. Could we find
shorter names? Some naming suggestions follows:

### Forward ranges

 * ForwardRange (no: every range is forward, so it is redundant)
 * Range
 
### Bidirectional ranges

Best ones:
 
 * BidirectionalRange (no: too long)
 * DuplexRange (no: duplex term may not be well-known)
 * BidiRange (no: non-standard abbreviation)
 * ReversibleRange
 
Others:

 * TwoWayRange (no: don't like two-part names)
 * BiRange (no: confused with two parallel ranges)
 * LeftRightRange (no: don't like two-part names, looks bad)
 * BothRange (no: uninformative)
 * ListRange (no: confused with only being applicable to std::list)
 * LinkedRange (no: forward ranges are also linked, uninformative)
 * LinkRange (no: forward ranges are also linked, uninformative)
 * DoubleRange (no: confused with two parallel ranges)
 * ChainedRange (no: uninformative, forward ranges are also chained)
 * SequentialRange (no: forward ranges are also sequential)
 * SequenceRange (no: forward ranges are also sequences)
 * NeighborRange (no: uninformative, graph nodes have neighbors too)
 * AdjacentRange (no: uninformative, graph nodes have adjacencies too)
 
### Random access ranges

Best ones:

 * RandomAccessRange (no: too long, two-part)
 * IndexedRange (yes: like an indexed set, no: indexable, not indexed)
 * IndexableRange 

Others:
 
 * RandomRange (no: confused with random values)
 * ArrayRange (no: confused with only being applicable to arrays)
 * VectorRange (no: confused with only being applicable to std::vector)
 * CompleteRange (like in a complete graph, no: not recognized)

### Extensions to iterators

The names of the ranges should extend nicely to iterators.

 * Iterator
 * ReversibleIterator
 * IndexableIterator
 
This also gives a nice 'associativity of names':

 * Iterator_Range ~ IteratorRange
 * ReversibleIterator_Range ~ Reversible_IteratorRange
 * IndexableIterator_Range ~ Indexable_IteratorRange

Transmitting a set of pairs generically
---------------------------------------

17.8.2011

The problem is to transmit a set of pairs as an input to a function.

### Option 1

Transmit two sequences of equal length, the other corresponding
to the first elements of pairs, and the other to the second elements
of pairs.

### Option 2

Transmit a sequence of a known type, and require from the type a
similar interface as some concrete type, such as std::pair.

### Option 3:

Transmit a sequence of pairs, and an object to extract the elements
of each pair.

Superclass delegation
---------------------

14.7.2011

Say that Logger is an abstract class. A Logger can be attached
as an observer to a (unique) Log object. Let us require that
whenever an object with a type of a subclass of Logger is 
destructed, it reports this beforehand to its corresponding Log 
(if it exists). This means that each Logger object must store
a pointer to the associated Log object. On the other hand,
each subclass of Logger must remember to report the destruction
to its Log.

If each subclass has to implement this reporting manually,
the same functionality is implemented over and over again,
which is redundant. On the other hand, the feature is
not at all specific to the subclasses and can be completely
implemented in the Logger superclass. This begs for factoring 
the functionality out of the subclass into the Logger class.
But are there problems with such a factoring?

It is perfectly valid to have concrete functions
implemented by the Logger, perhaps built using the abstract 
functions. However, how about member variables in an abstract
superclass? This results in the need for 'superclass delegation',
which is that constructors, copy constructors, and assignment
operators _must_ remember to call their superclass correspondences,
an operation which is otherwise not needed (since the superclass
has no state). This is again a redundancy, perhaps well described
as 'superclass delegation', which the implementor of the subclass 
might forget to do with unfortunate consequences.

The choice is then between two redundancies: 'superclass delegation'
or 'reimplementation of a features common to all subclasses'.
Between these two, the 'superclass delegation' is a better
option. The reasons are that

 * The common functionality can be varied, if needed, without much
 effort. This option is not practically available when the 
 functionality is replicated to all subclasses.
 
 * The superclass delegation approach scales with the increasing
 complexity of the common functionality.

Invasive reference counting
---------------------------

2.7.2011

In general, invasive reference counting (e.g. via `CountedPtr`) suggests 
that the counted objects should not be allocated in the stack. 
But whether the lifetime of an object should be decided by the amount of 
references or automatically by the stack, is object-dependent, and thus 
should not be decided on the class level.

_Pastel should get rid of `CountedPtr` and move on to use C++0x 
`shared_ptr` as needed._

Reference-counted pointers
--------------------------

2.7.2011

The `Log` class redirects its output to attached observers, called
`Loggers`. The `Log` is itself a `Logger`, to allow for composition.
The loggers are attached by reference. Should `Log` accept these
references as raw pointers, or as reference-counted pointers?
The problem here is that with raw pointers the references can become
invalid if the referred objects are destructed. A bit of reflection 
shows that the actual problem is to consider different options on 
what should happen when an observer object is destructed.

### Option 1: dangling references

After an observer object is destructed, the references to it
become invalid. Subsequent use of the observer object then cause 
a crash or similar. Avoiding crashes requires the user to detach 
the observer before destruction. As always, leaving something 
to a human's responsibility is a bad idea.

### Option 2: shared ownership

With reference counting, the observer is destructed only when the 
references to it goes to zero. If the `Log` has a reference to the 
observer, the observer is never destructed before detachment. This 
is shared ownership. It is not clear though that the `Log` should 
have such an ownership privilege. This forces the users of `Log`
to allocate loggers dynamically and store them in the smart pointer
given in the interface of `Log`.

### Option 3: automatic detachment on destruction

When a logger is destructed, it is automatically detached from the log. 
This requires that each log knows its loggers, and that each logger knows 
its logs. This makes the lifetimes of logs and loggers independent. As a 
simplification, it could be useful to restrict the number of attached-to 
logs to one. 

