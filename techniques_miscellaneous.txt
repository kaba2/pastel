Miscellaneous techniques
========================

[Parent]: techniques.txt

* Original text: 3.2.2009

Enums with scoping
------------------

Consider the following code:

[CppCode]:

	enum LoopType
	{
		None,
		Forward,
		Backward,
		PingPong
	};

	enum Direction
	{
		Forward,
		Backward,
		Left,
		Right
	};
	
	void setLoopType(LoopType loopType)
	{
		// ...
	}
	
	void move(Direction direction)
	{
		// ...
	}

	int main()	
	{
		setLoopType(Forward);
		move(Backward);
		
		return 0;
	}

This code won't compile because the enum values are not scoped inside LoopType and Direction.
Instead, the enum values reserve identifiers from the surrounding namespace. The solution
is to wrap enums inside a class, in effect offering the enum values their own namespace:

[CppCode]:
	
	class LoopType
	{
	public:
		enum Enum
		{
			None,
			Forward,
			Backward,
			PingPong
		};
	};

	class Direction
	{
	public:
		enum Enum
		{
			Forward,
			Backward,
			Left,
			Right
		};
	};

	void setLoopType(LoopType::Enum loopType)
	{
		// ...
	}
	
	void move(Direction::Enum direction)
	{
		// ...
	}

	int main()	
	{
		setLoopType(LoopType::Forward);
		move(Direction::Backward);
		
		return 0;
	}

The extra effort you need to do now is to rewrite the types of the enums as LoopType::Enum and Direction::Enum
instead of just LoopType and Direction. Additionally, you always have to be explicit with the enum values,
qualifying the enum of which you are referring to (e.g. LoopType::Forward). I find the the enum type name 
(e.g. LoopType::Enum) nice because it is in symmetry with the enum value names (e.g. LoopType::Forward) as 
if saying 'replace Enum with your desired enum value'.

Do not use unsigned integers
----------------------------

Or more precisely, only use them to represent bit fields.
Assume you have created an array container class. Its size can be altered via
a 'resize' member function which takes an integer as its parameter denoting the
desired size. While values from 0 towards infinity make sense for 'size',
this is not so with negative values. This is a precondition to the function:
all passed-in 'size' values should be non-negative. This should be both
documented and checked.

### Using an unsigned integer instead of checking a precondition

Sometimes people react to this situation by turning the variable into an 
unsigned integer. After all, this way one doubles the range of 
legal sizes for the array, compared to 'wasting one bit'. 
Unfortunately, it is very common in programming to
get integer calculations off by just a little amount (usually just by one).
Consider you have calculated a new array size by some formula
and you end up at -1 instead of the correct result 0. What happens
now is that because of the 2's complement representation the
integer becomes some very large integer. Thus, instead of resizing your
array to zero size you end up allocating an enormous amount of data.
However, you can't take this is as an error because every
value is legal to the 'resize' function. That is, you are not able
to detect a bug that is expected to happen frequently.

### Reserving space in the integer to detect common bugs

To fix this, you can sacrifice some of the parameter range to 
detect bugs: 'assert(size < maxInteger - bugThreshold)'.
However, while this test is correct computationally (dependening on the
fact that the integers are represented as 2's complement numbers),
it is logically a bit odd. You wouldn't want to read that in code.

The way out is to use a signed integer. What you wanted to say in the 
first place was that you do not accept negative values:
'assert(size >= 0)'. Now the test agrees with logic.
One should not think that a bit is wasted using signed
integers. Instead, one should think that the bit is in good use
allowing to detect common bugs.

### Looping with unsigned integers

Let us give another example where unsigned integers cause problems: 
looping over values from n to zero backwards:

[CppCode]:
	for (unsigned int i = n;i >= 0;--i)
	{
		// Do something.
	}
	
This code gets in an infinite loop,
since there are no negative values which would fail the loop test.
There is no natural fix to this problem with unsigned integers. Again,
the way out is to use signed integers:

[CppCode]:
	for (int i = n;i >= 0;--i)
	{
		// Do something.
	}

Anyway, if the iteration was over the range [-4, 15], say, you would be
using signed integers anyway: signed integers give your code consistency.

### Signed-unsigned conversion

Lastly, conversion between an unsigned integer and a signed integer
is an information destroying process in either direction.
When you get to such a situation there is no other solution than
to close your eyes and hope for the best.
However, you can avoid facing this problem _beforehand_ by avoiding
unsigned integers. This handles your code, but there's nothing
you can do to external code (apart from persuading the authors
to give up on unsigned integers). 
A most unfortunate example of this is 'std::size_t' used by the 
standard library which is an unsigned integer.

Abstract reals and integers
---------------------------

You should not work with concrete types, but by types
that model the desired abstract concept!
Rather than using the native types, abstract an integer used
for indices and counts as its own type. Do the same for reals.

[CppCode]:
	
	typedef int integer;
	typedef float real;
	
	int main()
	{
		for (integer i = 0;i < 5;++i)
		{
			// Do something.
		}
		
		const real piApprox = 3.14;
		
		return 0;
	}
	
Single floats work nicely as models for real numbers most of the time.
However, by doing this kind of abstraction it is possible to change the 
representation to a double if at some point it is found that the 
accuracy of a single float is not enough.

Do turn off some of the compiler warnings
-----------------------------------------

Some people take an obsession to eliminate every warning the
compiler has to offer. Paradoxically, this leads to worse code than
what can be achieved by a more relaxed approach.
I will now justify this claim by listing some of the compiler warnings
that I have turned off in Visual Studio 2008 and by explaining my reasons for doing that.

4351
new behavior: elements of array 'array' will be default initialized

This simply says that the behaviour of the compiler has changed since the last
version. Well, after checking the affected places, there is clearly no
need for this warning anymore in that particular project.

4996
'function': was declared deprecated

This warning is simply rubbish, since the functions which are referred to
are functions in the Standard Library which are not deprecated in the standard. 
The questionable intent here was probably to promote Microsofts 'safe' 
implementation of the standard library.

4018
'expression' : signed/unsigned mismatch

Assume you end up in the unfortunate situation that you must assign
an unsigned integer to a signed integer or vice versa. As discussed elsewhere
on this page, there is nothing that can be done to save the day because
both directions are information destroying. Some people at this 
situation use a cast to get rid of the warning. This is a bit of a self-deception.
After all, the problem is not resolved by the cast, it is only sweeped
under the rug. Assume that you some day end up suspecting
that a bug is actually being caused by a unsigned/signed conversion. Then you
have no way of finding the spots where that happens (except by manual inspection).
If instead you would have avoided the casting and turned off the compiler warning,
you could now enable the warning to spot those problematic places.

4244
'argument' : conversion from 'type1' to 'type2', possible loss of data. 

This warning refers to a floating point type being converted to an integer type.
It is self-evident that there is possible loss of data when doing the conversion.
In addition, because the cast generates equivalent code to that of without the cast, 
to me this warning serves no purpose. I also find the code looking
aesthetically better when I don't perform the cast. Finally, if there
is any day a suspicion that a bug is being caused by this kind of
operation, then the compiler can help me to locate the place.

Use precondition checking
-------------------------

[Link]: ensure.txt


