Experiences with CMake
======================

[[Parent]]: pastel.txt

The purpose of this page is to act as a blog as I am trying
to move to using CMake as my underlying cross-platform
build system. I found it surprisingly difficult to find 
practical information on the issues one faces. I am hoping
that my experiences could be helpful to others who later are
at the same situation. 

5.7.2010
--------

I am starting this blog a bit later than I actually started
to solve the issues with CMake. So here's what I've done already.

### Installing CMake

I began by installing CMake on my Windows XP machine. This was 
pretty painless, except that the installation program was unable 
to update my Path environment variable for some reason. No problem,
I just added the CMake directory manually there, and I was done.

### The book

So now I needed information about how the CMake works,
and what I should do to set up a single build system which 
works on various platforms. Since I like to read books, 
my first reaction was to see if there were any books written 
about CMake. As a result, I found one book, called 'Mastering CMake',
which also seemed to be the only one. I then went to a familiar Finnish 
book net-store to order this book, but unfortunately their search did 
not recognize the book. Other Finnish net-stores did not recognize it 
either. It seemed to me that the only way to get the book was to order 
it from Amazon. I almost did, but I was discouraged by the fact that
the standard shipping would take a month, and I didn't want to pay
extra for a faster shipping. I then decided to look for more information
in the net.

I quickly found a tutorial for CMake which was actually an excerpt
from the book. Unfortunately, I was disappointed by the quality of that 
excerpt since I considered it badly written. It left a lot of rows from 
the example code unexplained and considered, in my opinion, tasks that are 
irrelevant when you are really at the beginning of your learning process. Based on
that, I'm not sure if I actually want the book anymore (on the other there are
no alternatives).

### Overall idea

Googling some more I formed the following intuition. For each directory
of your project, you create a file name `CMakeLists.txt`. These files contain
everything that is needed to build your project in various platforms.
To build your project, you call the `cmake` program by giving it the root
directory of your project (which contains a `CMakeLists.txt`).
However, as a result you do not get libraries and executables. Instead, `cmake`
generates files for a specific native build-system to do the job.
There are several native build-systems which you can choose
the `cmake` to generate files for. For example, on Windows platform you might
want to generate Visual Studio project files or Microsoft nmake files, and
on Linux you might want to generate the usual Makefiles.

### A quickstart

I am a fan of quickstarts. I think documentation should be written so as to
give the essential information as fast as possible to save everyone's time,
and only later get more and more detailed. CMake seems to be missing
such documentation (which could be called tutorials). It has this one-page 
html documentation which seems like an incomplete reference documentation.

I wanted a quickstart, but this was again a bit hard to find. But I did find
helpful PowerPoint slides prepared by someone who was perhaps representing CMake 
to his work-mates. From them I deduced the following about CMakeLists.txt files:

 * Comment-lines are marked with an asterisk '#', and continue
 to the end of line.
 
 * Each file consists of a sequence of _comments_ and _commands_.
 
 * A command is of the form `name_of_command(arguments)`.
 
 * Each file should state the required CMake version number by a command
 of the form `cmake_minimum_required(VERSION 2.8)`, which I guess should
 be placed as the first command.
 
 * To make the build system to recurse on a sub-directory with its own 
 respective CMakeLists.txt, you use the command 
 `add_subdirectory(name_of_subdirectory)`. This command connects the 
 different build files together.

 * You can form a list of strings by the command 
 `set(name_of_list element_1 element_2 ...)`. For example: 
 `set(FruitSet orange "red apple" "green apple")`. The use of double-quotes
 is optional, however, you need them to interpret spaces as part of the 
 string, rather than as an element separator. Such lists are useful, for 
 example, to group together the source files you are going to compile and 
 link together.
 
 * To add a library (static or shared) to your project, you use
 the command `add_library(name_of_library list_of_source_files)`.
 
 * To add an executable to your project, you use the command
 `add_executable(name_of_executable list_of_source_files)`.

 * At the root CMakeLists.txt you should name your project by using the
 command `project(name_of_project)`.
 
 * To tell CMake about paths to include files, you use the command
 `include_directories(list_of_directories)`.
 
 * To tell CMake about paths to library files, you use the command
 `link_directories(list_of_directories)`.
 
 * To link stuff together, you use the command:
 `target_link_libraries(name_of_library_or_executable list_of_libraries)`.
 When giving the names, you leave the extensions off (since different
 platforms have different extensions).

Using this information I was already able to build a small example 
project.

### Visual Studio project folders

In Visual Studio, I like to group my project files into a hierarchy
of project folders (it's like a virtual directory tree), since otherwise 
I would spend a lot of time just to find some file. This also helps me 
to keep a clear overall image of the project.

I was pleased to find out that CMake supports such a grouping of
source files by the command `source_group(project_folder_name list_of_files)`.
Sub-folders can be specified by using the syntax 
`name_of_folder\\level_2_folder\\level_3_folder`.
However, note that this is for grouping purposes only and does not affect
which files will be compiled and linked.

So what I started to experiment with was to take one sub-library
of my real project and to try to copy its project folder hierarchy
to CMakeLists.txt. After writing something like 20 lines I was already convinced
that the task was not something that I would like to do manually for
all my thousand plus files. I was also convinced that I'd surely make
a lot of errors in this process, and perhaps miss files. 

What I needed was automation: a converter program to extract the source 
folder tree from a Visual Studio project and to write out the corresponding CMake
source grouping. In some hours I managed to put up a not-so-general 
Python script to do this. I also created a Windows Explorer action
for it, so that I could right-click on a Visual Studio project file
and choose "Convert to CMake". This would run the Python script, write
the results to a file, and open the file in Notepad. I then
copied the contents to the actual CMakeLists.txt. This way the conversion
became quite pleasant.

### Obtaining the list of source files in Windows

Since the source grouping does not have anything to do with the files
that are actually used to build the libraries and executables, I also
needed a way to get the set of source files. I incorporated this to
my Python script, which simply gathered all the files in the Visual
Studio project folder hierarchy into a single CMake list.
However, my first approach was to obtain the list of files in a directory by 
using the following DOS script:

	dir *.cpp *.h *.hpp *.txt *.m /a /b /-p /o:gen >C:\Temp\List_Files.txt
	start notepad C:\Temp\List_Files.txt

To make it easy to use, I again provided a Windows Explorer action to easily
run this script via a right-click on a directory.

### Compiler-specific tweaking

Using what I had learned and constructed by now, it was easy for me to
write all the needed CMakeLists.txt files for all of my real project.
I ran `cmake` on it, and after correcting some typos, I was able
to build my project under CMake the first time. 

However, I was now wondering about two things. First, under Visual Studio, I had
disabled a bunch of warnings (for good reasons). Since CMake did not know
about this, the result was a lot of warning messages in compilation. How
would I be able disable these warnings when Visual Studio is used as the
target? Second, how would I tell Visual Studio to disable language extensions,
so that the compiler followed the C++ standard better?

Of course, I was actually wondering only about a single thing: how would I 
specialize the building process so that I could pass compiler-specific options?
The answer is in two parts. First, CMake allows for conditional constructs using
the commands `if`, `else`, and `endif`. Second, CMake provides a variable
`CMAKE_GENERATOR` which describes the targeted build-system. For Visual Studio 8,
for example this variable contains the string `Visual Studio 8`, which is quite
logical. So I ended up writing the following to my root CMakeLists.txt:

	if(${CMAKE_GENERATOR} MATCHES "Visual Studio.*")

	# Disable some warnings.
	add_definitions("/wd4305 /wd4244 /wd4251 /wd4351")
	add_definitions("/wd4996 /wd4267 /wd4018 /wd4312")
	add_definitions("/wd4224 /wd4180 /wd4800 /wd4804")

	# Disable language extensions.
	add_definitions("/Za")

	# Disable Microsoft's Secure STL stuff.
	add_definitions("/D_SECURE_SCL=0")
	add_definitions("/D_HAS_ITERATOR_DEBUGGING=0")

	endif()




