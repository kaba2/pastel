Reinterpret casts
=================

[[Parent]]: techniques.txt

In this section we will look at a particular problem related to the `reinterpret_cast`.

Problem
-------

Suppose the following class hierachy:

[[CppCode]]:
	class Base { void f() {} };
	class A : public Base {};
	class B : public Base {};

Is the following correct?

[[CppCode]]:
	A* a = new A;
	B* u = reinterpret_cast<B*>(a);

	// Correct?
	u->f();

Motivation
----------

The motivation for this problem comes from debugging data structures through iterators. 

The [double-linked list][List] has two types of nodes, the `End_Node`, and the `Data_Node`, with a common base-type `Node`. The `End_Node` is used as a sentinel node, and contains optional user-defined end-data. The `Data_Node` is used for an actual element of the list, which contains optional user-defined data.

Which type of a node pointer should a list's iterator contain? The `Node*` surely works, but then it is not possible to directly examine the possible user-data in a node through the debugger. A better choice seems to be `Data_Node*`, although it would still not be possible to examine the end-data. The question then arises whether it is correct to refer to the fields of `Node` through `Data_Node*`, when the underlying object is actually `End_Node`. 

[List]: [[Ref]]: list.txt

Reinterpretation loops
----------------------

A _reintepretation sequence_ is a sequence of `reinterpet_cast`s. A _reinterpretation loop_ is a reinterpretation sequence which starts from and ends to the same type. The C++ Standard guarantees that (5.2.10 Reinterpret cast 7)

	An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue v of object pointer type is converted to the object pointer type "pointer to cv T", the result is static_cast<cv T*>(static_cast<cv void*>(v)). Converting a prvalue of type "pointer to T1" to the type "pointer to T2" (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value.

Therefore a reinterpretation loop preserves the value of a pointer.

[[CppCode]]:
	A* a = new A;
	
	// Reinterpretation loop.
	B* u = reinterpret_cast<B*>(a);
	void* v = reinterpret_cast<void*>(u);
	A* w = reinterpret_cast<A*>(v);

	ASSERT(a == w);

Base members through a reinterpreted pointer
--------------------------------------------

Suppose `A*` is reinterpreted as `B*`, and then `Base::f` is referenced through that. Is this guaranteed to work by the C++ Standard? It seems to me that it is not. The C++ Standard guarantees that (5.2.9 Static cast 13)

	A prvalue of type "pointer to cv1 void" can be converted to a prvalue of type "pointer to cv2 T," where T is an object type and cv2 is the same cv-qualification as, or greater cv-qualification than, cv1. The null pointer value is converted to the null pointer value of the destination type. If the original pointer value represents the address A of a byte in memory and A satisfies the alignment requirement of T, then the resulting pointer value represents the same address as the original pointer value, that is, A. The result of any other such pointer conversion is unspecified. A value of type pointer to object converted to "pointer to cv void" and back, possibly with different cv-qualification, shall have its original value.

The question comes down to whether the address of an object of a derived class is always the same as the address of an object of the base class. Unfortunately, the memory layout is implementation-defined. For example, if the base-class contains a virtual method, then according to the [Itanium ABI][Itanium] (2.4 Non-POD class types), adopted by `gcc` and `clang`, the virtual table pointer is stored at the start of the derived object. This makes the base-class of a derived class have an address one pointer greater. On the other hand, the claim holds in the Itanium ABI and Visual Studio when polymorphic behaviour is not present. This happens to be the use-case for many generic data-structures. However, without the backing of the C++ Standard, this is not portable enough.

[[CppCode]]:
	A* a = new A;
	B* u = reinterpret_cast<B*>(a);

	// Correct; a reinterpretation loop.
	reinterpret_cast<A*>(u)->f();

	// Equivalent to above.
	static_cast<A*>(static_cast<void*>(u))->f();

	// Not always correct.
	static_cast<B*>(static_cast<void*>(u))->f();

	// Equivalent to above.
	reinterpret_cast<B*>(u)->f();

	// Equivalent to above.
	u->f();

[Itanium]: http://mentorembedded.github.io/cxx-abi/abi.html#class-types
